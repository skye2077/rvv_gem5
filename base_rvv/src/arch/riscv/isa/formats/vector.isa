// SPDX-FileCopyrightText: Copyright Â© 2022 by Rivos Inc.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

def template VectorVMUNARY0Constructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVMUNARY0OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vid.v          31..26=0x14 vm 24..20=0 19..15=0x11 14..12=0x2 vd 6..0=0x57
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecDestRegs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
        }

        _numVecSrcRegs = _numSrcRegs;

        flags[IsVector] = true;;
    }
}};

def template VectorVMUNARYVs20Constructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVMUNARY0OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // viota.m        31..26=0x14 vm vs2 19..15=0x10 14..12=0x2 vd 6..0=0x57
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecDestRegs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
        }

        setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2));

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
        }

        _numVecSrcRegs = _numSrcRegs;

        flags[IsVector] = true;;
    }
}};

def template VectorVWXUNARY0Constructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVWXUNARY0OpClass)
    {
        %(set_reg_idx_arr)s;
        %(constructor)s;
    }
}};

def template VectorVWXUNARY0MaskConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVWXUNARY0OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vcpop.m        31..26=0x10 vm vs2 19..15=0x10 14..12=0x2 rd 6..0=0x57
        // vfirst.m       31..26=0x10 vm vs2 19..15=0x11 14..12=0x2 rd 6..0=0x57
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2));

        setDestRegIdx(_numDestRegs++, RegId(IntRegClass, RD));
        _numIntDestRegs++;

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
        }

        _numVecSrcRegs = _numSrcRegs;

        flags[IsVector] = true;;
    }
}};

def template VectorVRXUNARY0Constructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVRXUNARY0OpClass)
    {
        %(set_reg_idx_arr)s;
        %(constructor)s;
    }
}};

def template VectorVRFUNARY0Constructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVRFUNARY0OpClass)
    {
        %(set_reg_idx_arr)s;
        %(constructor)s;
    }
}};

def template VectorVWFUNARY0Constructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVWFUNARY0OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;
        setDestRegIdx(_numDestRegs++, RegId(FloatRegClass, FD));
        _numFPDestRegs++;

        setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2));

        flags[IsFloating] = true;;
        flags[IsVector] = true;;
    }
}};

def template VectorVFUNARY0Constructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVFUNARY0OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vfcvt.rtz.xu.f.v 31..26=0x12 vm vs2 19..15=0x06 14..12=0x1 vd 6..0=0x57
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecDestRegs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);
        assert((VS2 % alignToPowerOfTwo(_numVecDestRegs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
        }

        _numVecSrcRegs = _numSrcRegs;

        flags[IsFloating] = false;
        flags[IsVector] = true;;
    }
}};

def template VectorOPIVIConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorOPIVIOpClass)
    {
        %(set_reg_idx_arr)s;
        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vadd.vi        31..26=0x00 vm vs2 simm5 14..12=0x3 vd 6..0=0x57
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecSrcRegs = _numVecDestRegs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);
        assert((VS2 % alignToPowerOfTwo(_numVecDestRegs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorVdVs2Rs1Constructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVdVs2Rs1OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example: vadd.vx        31..26=0x00 vm vs2 rs1 14..12=0x4 vd 6..0=0x57
        setSrcRegIdx(_numSrcRegs++, RegId(IntRegClass, RS1));

        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecSrcRegs = _numVecDestRegs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);
        assert((VS2 % alignToPowerOfTwo(_numVecDestRegs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorVdVs2Fs1Constructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVdVs2Fs1OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vfadd.vf        31..26=0x00 vm vs2 rs1 14..12=0x5 vd 6..0=0x57
        setSrcRegIdx(_numSrcRegs++, RegId(FloatRegClass, RS1));

        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecSrcRegs = _numVecDestRegs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);
        assert((VS2 % alignToPowerOfTwo(_numVecDestRegs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsFloating] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorIntegerExtensionConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorIntegerExtensionOpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vzext.vf8      31..26=0x12 vm vs2 19..15=2 14..12=0x2 vd 6..0=0x57
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        // EEW = SEW for Vd
        _numVecDestRegs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
        }

        uint32_t divisor = 0;
        switch(RS1) {
            case 2:
            case 3:
                divisor = 8;
                break;
            case 4:
            case 5:
                divisor = 4;
                break;
            case 6:
            case 7:
                divisor = 2;
                break;
        }

        assert(sewb / divisor);

        // EEW = SEW/divisor for Vs2
        uint32_t numVs2Regs =
            ceil((float) machVl / (VecRegSizeBytes / (sewb / divisor)));
        assert((VS2 % alignToPowerOfTwo(numVs2Regs)) == 0);

        for (int i = 0; i < numVs2Regs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorMaskRegisterVdVs2Vs1Constructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorMaskRegisterVdVs2Vs1OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vmxnor.mm      31..26=0x1f vm vs2 vs1 14..12=0x2 vd 6..0=0x57
        // these instructions all operate on single vector registers regardless
        // of the setting of the vlmul field in vtype.
        _numVecDestRegs = 1;

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS1 + i));
        }

        // Vector mask logical instructions are always unmasked,
        // so there are no inactive elements, and the encodings
        // with vm=0 are reserved.
        assert(VM == 1);

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorMaskRegisterVdVs2Constructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorMaskRegisterVdVs2OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vmsbf.m        31..26=0x14 vm vs2 19..15=0x01 14..12=0x2 vd 6..0=0x57
        // these instructions all operate on single vector registers regardless
        // of the setting of the vlmul field in vtype.
        _numVecDestRegs = 1;

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorWholeRegisterMoveConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorWholeRegisterMoveOpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vmv1r.v        31..26=0x27 25=1 vs2 19..15=0 14..12=0x3 vd 6..0=0x57
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        // <19:15> which is also Rs1 indicates the number of regs to move.
        _numVecSrcRegs = _numVecDestRegs = RS1 + 1;

        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);
        assert((VS2 % alignToPowerOfTwo(_numVecSrcRegs)) == 0);

        if (VD == VS2) {
            // Treated as a NOP.
            _numVecSrcRegs = _numVecDestRegs = 0;
        }

        for (int i = 0; i < _numVecSrcRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD));
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorVdMaskVs2Rs1Constructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVdVs2Rs1OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example: vadd.vx        31..26=0x00 vm vs2 rs1 14..12=0x4 vd 6..0=0x57
        setSrcRegIdx(_numSrcRegs++, RegId(IntRegClass, RS1));

        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecSrcRegs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VS2 % alignToPowerOfTwo(_numVecSrcRegs)) == 0);

        for (int i = 0; i < _numVecSrcRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD));
        ++_numVecDestRegs;

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorVdMaskOPIVIConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorOPIVIOpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecSrcRegs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VS2 % alignToPowerOfTwo(_numVecSrcRegs)) == 0);

        for (int i = 0; i < _numVecSrcRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD));
        ++_numVecDestRegs;

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorVdMaskVs2Vs1Constructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVdVs2Vs1OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example: vmsbc.vv       31..26=0x13 25=1 vs2 vs1 14..12=0x0 vd 6..0=0x57
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        uint32_t numVecVs2Vs2Regs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VS2 % alignToPowerOfTwo(numVecVs2Vs2Regs)) == 0);
        assert((VS1 % alignToPowerOfTwo(numVecVs2Vs2Regs)) == 0);

        for (int i = 0; i < numVecVs2Vs2Regs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
            ++_numVecSrcRegs;
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS1 + i));
            ++_numVecSrcRegs;
        }

        setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD));
        ++_numVecDestRegs;

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorWideningVXConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVdVs2Rs1OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example: vadd.vx        31..26=0x00 vm vs2 rs1 14..12=0x4 vd 6..0=0x57
        setSrcRegIdx(_numSrcRegs++, RegId(IntRegClass, RS1));

        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecSrcRegs = ceil((float) machVl / (VecRegSizeBytes / sewb));
        _numVecDestRegs = ceil((float) machVl / (VecRegSizeBytes / (sewb * 2)));
        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);
        assert((VS2 % alignToPowerOfTwo(_numVecSrcRegs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
        }

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorWideningWVConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorWideningWVOpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vwadd.wv       31..26=0x35 vm vs2 vs1 14..12=0x2 vd 6..0=0x57
        // 2*SEW = 2*SEW +/- SEW
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        uint32_t numVs1Regs = ceil((float) machVl / (VecRegSizeBytes / sewb));
        _numVecDestRegs = ceil((float) machVl / (VecRegSizeBytes / (2 * sewb)));
        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);
        assert((VS2 % alignToPowerOfTwo(_numVecDestRegs)) == 0);
        assert((VS1 % alignToPowerOfTwo(numVs1Regs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
        }

        for (int i = 0; i < numVs1Regs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS1 + i));
        }

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorWideningVVConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorWideningVVOpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vwsubu.vv      31..26=0x32 vm vs2 vs1 14..12=0x2 vd 6..0=0x57
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        uint32_t numVs2Regs = ceil((float) machVl / (VecRegSizeBytes / sewb));
        _numVecDestRegs = ceil((float) machVl / (VecRegSizeBytes / (sewb*2)));
        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);
        assert((VS2 % alignToPowerOfTwo(numVs2Regs)) == 0);
        assert((VS1 % alignToPowerOfTwo(numVs2Regs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
        }

        for (int i = 0; i < numVs2Regs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        for (int i = 0; i < numVs2Regs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS1 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorWideningFPReductionConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVdVs2Vs1OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vfwredosum.vs vd, vs2, vs1, vm
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecSrcRegs = ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VS2 % alignToPowerOfTwo(_numVecSrcRegs)) == 0);

        _numVecDestRegs = 1;

        setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD));

        setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS1));

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsFloating] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorSingleWidthIntegerReductionConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVdVs2Vs1OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vredsum.vs     31..26=0x00 vm vs2 vs1 14..12=0x2 vd 6..0=0x57
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        uint32_t numVs2Regs = ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VS2 % alignToPowerOfTwo(numVs2Regs)) == 0);

        _numVecDestRegs = 1;

        setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD));

        setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS1));

        for (int i = 0; i < numVs2Regs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorWideningVdVs2Constructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorWideningVdVs2OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vfwcvt.f.f.v      31..26=0x12 vm vs2 19..15=0x0C 14..12=0x1 vd 6..0=0x57
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecSrcRegs = ceil((float) machVl / (VecRegSizeBytes / sewb));
        _numVecDestRegs = ceil((float) machVl / (VecRegSizeBytes / (sewb*2)));
        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);
        assert((VS2 % alignToPowerOfTwo(_numVecDestRegs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
        }

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsFloating] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorWideningVdFs1Vs2Constructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVdVs2Fs1OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vfwmsac.vf     31..26=0x3e vm vs2 rs1 14..12=0x5 vd 6..0=0x57
        setSrcRegIdx(_numSrcRegs++, RegId(FloatRegClass, RS1));

        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecSrcRegs = ceil((float) machVl / (VecRegSizeBytes / sewb));
        _numVecDestRegs = ceil((float) machVl / (VecRegSizeBytes / (sewb*2)));
        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);
        assert((VS2 % alignToPowerOfTwo(_numVecDestRegs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
        }

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsFloating] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorNarrowingVVConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorNarrowingVVOpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vnclipu.wv     31..26=0x2e vm vs2 vs1 14..12=0x0 vd 6..0=0x57
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        // EEW = SEW for Vs1 and Vd
        uint32_t numVs1Regs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VS1 % alignToPowerOfTwo(numVs1Regs)) == 0);

        _numVecDestRegs = numVs1Regs;
        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS1 + i));
        }

        // EEW = 2 * SEW for Vs2
        uint32_t numVs2Regs =
            ceil((float) machVl / (VecRegSizeBytes / (sewb * 2)));
        assert((VS2 % alignToPowerOfTwo(numVs2Regs)) == 0);

        for (int i = 0; i < numVs2Regs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorNarrowingWXConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorNarrowingWXOpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vnclipu.wx     31..26=0x2e vm vs2 rs1 14..12=0x4 vd 6..0=0x57
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        // EEW = SEW for Vd
        _numVecDestRegs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
        }

        setSrcRegIdx(_numSrcRegs++, RegId(IntRegClass, RS1));

        // EEW = 2 * SEW for Vs2
        uint32_t numVs2Regs =
            ceil((float) machVl / (VecRegSizeBytes / (sewb * 2)));
        assert((VS2 % alignToPowerOfTwo(numVs2Regs)) == 0);

        for (int i = 0; i < numVs2Regs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorNarrowingVIConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorNarrowingVIOpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vnclipu.wv     31..26=0x2e vm vs2 vs1 14..12=0x0 vd 6..0=0x57
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        // EEW = SEW for Vd
        _numVecDestRegs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
        }

        // EEW = 2 * SEW for Vs2
        uint32_t numVs2Regs =
            ceil((float) machVl / (VecRegSizeBytes / (sewb * 2)));
        assert((VS2 % alignToPowerOfTwo(numVs2Regs)) == 0);

        for (int i = 0; i < numVs2Regs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorOPIVXMaskConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVdVs2Rs1OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vmseq.vx       31..26=0x18 vm vs2 rs1 14..12=0x4 vd 6..0=0x57
        // Vd is a mask
        setSrcRegIdx(_numSrcRegs++, RegId(IntRegClass, RS1));

        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecSrcRegs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VS2 % alignToPowerOfTwo(_numVecSrcRegs)) == 0);

        for (int i = 0; i < _numVecSrcRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD));
        ++_numVecDestRegs;

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorOPIVIMaskConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVdVs2Rs1OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecSrcRegs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VS2 % alignToPowerOfTwo(_numVecSrcRegs)) == 0);

        for (int i = 0; i < _numVecSrcRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD));
        ++_numVecDestRegs;

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorIntegerCompareVIConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorOPIVIOpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vmseq.vi       31..26=0x18 vm vs2 simm5 14..12=0x3 vd 6..0=0x57
        // Vd is a mask
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecSrcRegs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VS2 % alignToPowerOfTwo(_numVecSrcRegs)) == 0);

        for (int i = 0; i < _numVecSrcRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD));
        ++_numVecDestRegs;

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsInteger] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorFloatCompareVFConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVdVs2Rs1OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vmfeq.vf       31..26=0x18 vm vs2 rs1 14..12=0x5 vd 6..0=0x57
        // Vd is a mask
        setSrcRegIdx(_numSrcRegs++, RegId(FloatRegClass, RS1));

        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecSrcRegs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VS2 % alignToPowerOfTwo(_numVecSrcRegs)) == 0);

        for (int i = 0; i < _numVecSrcRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD));
        ++_numVecDestRegs;

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsFloating] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorFloatCompareVVConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVdVs2Rs1OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vmflt.vv       31..26=0x1b vm vs2 vs1 14..12=0x1 vd 6..0=0x57
        // Vd is a mask
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecSrcRegs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VS2 % alignToPowerOfTwo(_numVecSrcRegs)) == 0);

        for (int i = 0; i < _numVecSrcRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS1 + i));
        }

        setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD));
        ++_numVecDestRegs;

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsFloating] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorVdVs2Vs1OpConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVdVs2Vs1OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vadd.vv         31..26=0x00 vm vs2 vs1 14..12=0x0 vd 6..0=0x57
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecDestRegs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);
        assert((VS1 % alignToPowerOfTwo(_numVecDestRegs)) == 0);
        assert((VS2 % alignToPowerOfTwo(_numVecDestRegs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS1 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
        }

        _numVecSrcRegs = _numSrcRegs;

        flags[IsInteger] = false;
        flags[IsVector] = true;;
    }
}};

def template VectorIntegerCompareVVConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorVdVs2Vs1OpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vmseq.vv       31..26=0x18 vm vs2 vs1 14..12=0x0 vd 6..0=0x57
        uint32_t sewb = getSew(machVtype.vsew) / 8;

        _numVecSrcRegs =
            ceil((float) machVl / (VecRegSizeBytes / sewb));
        assert((VS1 % alignToPowerOfTwo(_numVecSrcRegs)) == 0);
        assert((VS2 % alignToPowerOfTwo(_numVecSrcRegs)) == 0);

        for (int i = 0; i < _numVecSrcRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS1 + i));
        }

        setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD));
        ++_numVecDestRegs;

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsInteger] = false;
        flags[IsVector] = true;;
    }
}};

def template VectorUnitStrideMemLoadConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorUnitStrideMemLoadOpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        setSrcRegIdx(_numSrcRegs++, RegId(IntRegClass, RS1));

        uint32_t eewb = 0;
        switch (FUNCT3) {
            case 0:
                eewb = 1;
                break;
            case 5:
                eewb = 2;
                break;
            case 6:
                eewb = 4;
                break;
            case 7:
                eewb = 8;
                break;
        }

        if (LUMOP == 0 || LUMOP == 0x10) {
            // vle32.v        nf 28=0 27..26=0 vm 24..20=0 rs1 14..12=0x6  vd 6..0=0x07
            // vle32ff.v        nf 28=0 27..26=0 vm 24..20=0x10 rs1 14..12=0x6  vd 6..0=0x07
            _numVecDestRegs = ceil((float) machVl / (VecRegSizeBytes/eewb));
        } else if (LUMOP == 0x8) {
            // vl1re16.v      31..29=0 28=0 27..26=0 25=1 24..20=0x08 rs1 14..12=0x5 vd  6..0=0x07
            // vl2re16.v      31..29=1 28=0 27..26=0 25=1 24..20=0x08 rs1 14..12=0x5 vd  6..0=0x07
            // vl4re16.v      31..29=3 28=0 27..26=0 25=1 24..20=0x08 rs1 14..12=0x5 vd  6..0=0x07
            // vl8re16.v      31..29=7 28=0 27..26=0 25=1 24..20=0x08 rs1 14..12=0x5 vd  6..0=0x07
            _numVecDestRegs = NF + 1;
        } else {
            printf("ERROR: Unknown LUMOP value 0x%x for load\n", LUMOP);
        }

        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsLoad] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorStridedMemLoadConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorStridedMemLoadOpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vlse64.v        nf 28=0 27..26=2 vm rs2 rs1 14..12=0x7  vd 6..0=0x07
        setSrcRegIdx(_numSrcRegs++, RegId(IntRegClass, RS1));
        setSrcRegIdx(_numSrcRegs++, RegId(IntRegClass, RS2));

        uint32_t eewb = 0;
        switch (FUNCT3) {
            case 0:
                eewb = 1;
                break;
            case 5:
                eewb = 2;
                break;
            case 6:
                eewb = 4;
                break;
            case 7:
                eewb = 8;
                break;
        }

        _numVecDestRegs = ceil((float) machVl / (VecRegSizeBytes/eewb));
        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsLoad] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorIndexedMemLoadConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorIndexedMemLoadOpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vluxei32.v     nf 28=0 27..26=1 vm vs2 rs1 14..12=0x6  vd 6..0=0x07
        setSrcRegIdx(_numSrcRegs++, RegId(IntRegClass, RS1));

        uint32_t eewb = 0;
        switch (FUNCT3) {
            case 0:
                eewb = 1;
                break;
            case 5:
                eewb = 2;
                break;
            case 6:
                eewb = 4;
                break;
            case 7:
                eewb = 8;
                break;
        }

        // The data vector register group has EEW=SEW, EMUL=LMUL,
        // while the offset vector register group has EEW
        // encoded in the instruction and EMUL=(EEW/SEW)*LMUL.
        _numVecSrcRegs =
            ceil((float) machVl / (VecRegSizeBytes/eewb));
        assert((VS2 % alignToPowerOfTwo(_numVecSrcRegs)) == 0);

        uint32_t sewb = getSew(machVtype.vsew) / 8;
        _numVecDestRegs =
            ceil((float) machVl / (VecRegSizeBytes/sewb));
        assert((VD % alignToPowerOfTwo(_numVecDestRegs)) == 0);

        for (int i = 0; i < _numVecDestRegs; ++i) {
            setDestRegIdx(_numDestRegs++, RegId(VecRegClass, VD + i));
        }

        for (int i = 0; i < _numVecSrcRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsLoad] = true;
        flags[IsVector] = true;;
    }
}};

def template  VectorIndexedMemStoreConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorIndexedMemStoreOpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        // Example:
        // vsuxei32.v     nf 28=0 27..26=1 vm vs2 rs1 14..12=0x6 vs3 6..0=0x27
        setSrcRegIdx(_numSrcRegs++, RegId(IntRegClass, RS1));

        uint32_t eewb = 0;
        switch (FUNCT3) {
            case 0:
                eewb = 1;
                break;
            case 5:
                eewb = 2;
                break;
            case 6:
                eewb = 4;
                break;
            case 7:
                eewb = 8;
                break;
        }

        // The data vector register group has EEW=SEW, EMUL=LMUL,
        // while the offset vector register group has EEW
        // encoded in the instruction and EMUL=(EEW/SEW)*LMUL.
        uint32_t sewb = getSew(machVtype.vsew) / 8;
        uint32_t numVs3VecRegs =
            ceil((float) machVl / (VecRegSizeBytes/sewb));
        assert((VS3 % alignToPowerOfTwo(numVs3VecRegs)) == 0);

        for (int i = 0; i < numVs3VecRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS3 + i));
            ++_numVecSrcRegs;
        }

        uint32_t numVs2VecRegs =
            ceil((float) machVl / (VecRegSizeBytes/eewb));
        assert((VS2 % alignToPowerOfTwo(numVs2VecRegs)) == 0);

        for (int i = 0; i < numVs2VecRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS2 + i));
            ++_numVecSrcRegs;
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsLoad] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorUnitStrideMemStoreConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorUnitStrideMemStoreOpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        uint32_t eewb = 0;
        switch (FUNCT3) {
            case 0:
                eewb = 1;
                break;
            case 5:
                eewb = 2;
                break;
            case 6:
                eewb = 4;
                break;
            case 7:
                eewb = 8;
                break;
        }

        // Example:
        setSrcRegIdx(_numSrcRegs++, RegId(IntRegClass, RS1));

        if (LUMOP == 0) {
            // vse32.v        nf 28=0 27..26=0 vm 24..20=0 rs1 14..12=0x6 vs3 6..0=0x27
            _numVecSrcRegs = ceil((float) machVl / (VecRegSizeBytes/eewb));
        } else if (LUMOP == 0x8) {
            // vs1r.v         31..29=0 28=0 27..26=0 25=1 24..20=0x08 rs1 14..12=0x0 vs3 6..0=0x27
            _numVecSrcRegs = NF + 1;
        } else {
            // vs1r.v         31..29=0 28=0 27..26=0 25=1 24..20=0x08 rs1 14..12=0x0 vs3 6..0=0x27
            // vs2r.v         31..29=1 28=0 27..26=0 25=1 24..20=0x08 rs1 14..12=0x0 vs3 6..0=0x27
            // vs4r.v         31..29=3 28=0 27..26=0 25=1 24..20=0x08 rs1 14..12=0x0 vs3 6..0=0x27
            // vs8r.v         31..29=7 28=0 27..26=0 25=1 24..20=0x08 rs1 14..12=0x0 vs3 6..0=0x27
            printf("ERROR: Unknown LUMOP value 0x%x for store\n", LUMOP);
        }

        assert((VS3 % alignToPowerOfTwo(_numVecSrcRegs)) == 0);

        for (int i = 0; i < _numVecSrcRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS3 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsStore] = true;
        flags[IsVector] = true;;
    }
}};

def template VectorStridedMemStoreConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorStridedMemStoreOpClass)
    {
        %(set_reg_idx_arr)s;

        _numSrcRegs = 0;
        _numDestRegs = 0;
        _numFPDestRegs = 0;
        _numVecSrcRegs = 0;
        _numVecDestRegs = 0;
        _numVecElemDestRegs = 0;
        _numVecPredDestRegs = 0;
        _numIntDestRegs = 0;
        _numCCDestRegs = 0;

        uint32_t eewb = 0;
        switch (FUNCT3) {
            case 0:
                eewb = 1;
                break;
            case 5:
                eewb = 2;
                break;
            case 6:
                eewb = 4;
                break;
            case 7:
                eewb = 8;
                break;
        }

        // Example:
        // vsse64.v        nf 28=0 27..26=2 vm rs2 rs1 14..12=0x7 vs3 6..0=0x27
        setSrcRegIdx(_numSrcRegs++, RegId(IntRegClass, RS1));
        setSrcRegIdx(_numSrcRegs++, RegId(IntRegClass, RS2));

        _numVecSrcRegs = ceil((float) machVl / (VecRegSizeBytes/eewb));
        assert((VS3 % alignToPowerOfTwo(_numVecSrcRegs)) == 0);

        for (int i = 0; i < _numVecSrcRegs; ++i) {
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, VS3 + i));
        }

        if (VM == 0) {
            // Masked instruction.
            setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));
            ++_numVecSrcRegs;
        }

        flags[IsStore] = true;
        flags[IsVector] = true;;
    }
}};


def template VectorCfgConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst, RiscvISA::VTYPE machVtype, uint32_t machVl)
        : %(base_class)s("%(mnemonic)s", machInst, VectorCfgOpClass)
    {
        %(set_reg_idx_arr)s;
        %(constructor)s;
    }
}};

def template VectorVMUNARY0Execute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        for (uint32_t destVecRegID = 0; destVecRegID < _numVecDestRegs; ++destVecRegID) {
            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, destVecRegID);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[destVecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[destVecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID/2];
                        vmask = (vmask >> (destVecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vd = Vd_container.as<uint8_t>();
                    for (size_t regElemIdx = 0; regElemIdx < num_target_elements_in_reg; ++regElemIdx) {
                      if (bits(vmask, regElemIdx, regElemIdx) == 0) {
                          continue;
                      }

                      uint8_t elemIdx =
                        destVecRegID * num_target_elements_in_reg + regElemIdx;
                      %(code)s;
                    }
                } else if (sewb == 2) {
                    auto Vd = Vd_container.as<uint16_t>();
                    for (size_t regElemIdx = 0; regElemIdx < num_target_elements_in_reg; ++regElemIdx) {
                      if (bits(vmask, regElemIdx, regElemIdx) == 0) {
                          continue;
                      }

                      uint16_t elemIdx =
                        destVecRegID * num_target_elements_in_reg + regElemIdx;
                      %(code)s;
                    }
                } else if (sewb == 4) {
                    auto Vd = Vd_container.as<uint32_t>();
                    for (size_t regElemIdx = 0; regElemIdx < num_target_elements_in_reg; ++regElemIdx) {
                      if (bits(vmask, regElemIdx, regElemIdx) == 0) {
                          continue;
                      }

                      uint32_t elemIdx =
                        destVecRegID * num_target_elements_in_reg + regElemIdx;
                      %(code)s;
                    }
                } else if (sewb == 8) {
                    auto Vd = Vd_container.as<uint64_t>();
                    for (size_t regElemIdx = 0; regElemIdx < num_target_elements_in_reg; ++regElemIdx) {
                      if (bits(vmask, regElemIdx, regElemIdx) == 0) {
                          continue;
                      }

                      uint64_t elemIdx =
                        destVecRegID * num_target_elements_in_reg + regElemIdx;
                      %(code)s;
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    fault = std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorVMUNARYVs20Execute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        if (VS2 == VD) {
            // viota cannot have overlapping VS2 and Vd
            std::string error =
                csprintf("viota cannot have overlapping VS2 and Vd \n");
            return std::make_shared<IllegalInstFault>(error, machInst);
        }

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, 0);

        uint32_t sum_of_active_bits_in_mask = 0;

        for (uint32_t destVecRegID = 0; destVecRegID < _numVecDestRegs; ++destVecRegID) {
            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, destVecRegID);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[destVecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[destVecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID/2];
                        vmask = (vmask >> (destVecRegID % 2));
                        break;
                }
            }

            uint32_t vs2_mask = 0;
            switch(sewb) {
                case 1:
                    vs2_mask = Vs2_container.as<uint32_t>()[destVecRegID];
                    break;
                case 2:
                    vs2_mask = Vs2_container.as<uint16_t>()[destVecRegID];
                    break;
                case 4:
                    vs2_mask = Vs2_container.as<uint8_t>()[destVecRegID];
                    break;
                case 8:
                    vs2_mask = Vs2_container.as<uint8_t>()[destVecRegID/2];
                    vs2_mask = (vs2_mask >> (destVecRegID % 2));
                    break;
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vd = Vd_container.as<uint8_t>();
                    for (size_t regElemIdx = 0; regElemIdx < num_target_elements_in_reg; ++regElemIdx) {
                      if (bits(vmask, regElemIdx, regElemIdx) == 0) {
                          continue;
                      }

                      %(code)s;

                      if (bits(vs2_mask, regElemIdx, regElemIdx) == 1) {
                        ++sum_of_active_bits_in_mask;
                      }
                    }
                } else if (sewb == 2) {
                    auto Vd = Vd_container.as<uint16_t>();
                    for (size_t regElemIdx = 0; regElemIdx < num_target_elements_in_reg; ++regElemIdx) {
                      if (bits(vmask, regElemIdx, regElemIdx) == 0) {
                          continue;
                      }

                      %(code)s;

                      if (bits(vs2_mask, regElemIdx, regElemIdx) == 1) {
                        ++sum_of_active_bits_in_mask;
                      }
                    }
                } else if (sewb == 4) {
                    auto Vd = Vd_container.as<uint32_t>();
                    for (size_t regElemIdx = 0; regElemIdx < num_target_elements_in_reg; ++regElemIdx) {
                      if (bits(vmask, regElemIdx, regElemIdx) == 0) {
                          continue;
                      }

                      %(code)s;

                      if (bits(vs2_mask, regElemIdx, regElemIdx) == 1) {
                        ++sum_of_active_bits_in_mask;
                      }
                    }
                } else if (sewb == 8) {
                    auto Vd = Vd_container.as<uint64_t>();
                    for (size_t regElemIdx = 0; regElemIdx < num_target_elements_in_reg; ++regElemIdx) {
                      if (bits(vmask, regElemIdx, regElemIdx) == 0) {
                          continue;
                      }

                      %(code)s;

                      if (bits(vs2_mask, regElemIdx, regElemIdx) == 1) {
                        ++sum_of_active_bits_in_mask;
                      }
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    fault = std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorVWXUNARY0Execute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        uint64_t Rd = 0;
        const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, 0);

        if (fault == NoFault) {
            if (sewb == 1) {
                auto Vs2 = Vs2_container.as<uint8_t>();
                %(code)s;
                Rd = sext<8>(Rd);
            } else if (sewb == 2) {
                auto Vs2 = Vs2_container.as<uint16_t>();
                %(code)s;
                Rd = sext<16>(Rd);
            } else if (sewb == 4) {
                auto Vs2 = Vs2_container.as<uint32_t>();
                %(code)s;
                Rd = sext<32>(Rd);
            } else if (sewb == 8) {
                auto Vs2 = Vs2_container.as<uint64_t>();
                %(code)s;
                Rd = sext<64>(Rd);
            } else {
                std::string error = csprintf(
                    "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                fault = std::make_shared<IllegalInstFault>(error, machInst);
            }

            if (fault == NoFault) {
                %(op_wb)s;
            }
        }
        return fault;
    }
}};

def template VectorVWXUNARY0MaskExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        uint32_t vmask = UINT32_MAX;
        if (VM == 0) {
            const TheISA::VecRegContainer& Vmask_container =
                xc->readVecRegOperand(this, _numSrcRegs - 1);
            vmask = Vmask_container.as<uint32_t>()[0];
        }

        uint64_t Rd = 0;
        const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, 0);

        if (fault == NoFault) {
            auto Vs2 = Vs2_container.as<uint32_t>();
            %(code)s;

            if (fault == NoFault) {
                %(op_wb)s;
            }
        }
        return fault;
    }
}};

def template VectorVRXUNARY0Execute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        uint64_t Rs1 = xc->readIntRegOperand(this, 0);
        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, 0);

        if (fault == NoFault) {
            Rs1 &= mask(sewb * 8);
            if (sewb == 1) {
                auto Vd = Vd_container.as<uint8_t>();
                %(code)s;
            } else if (sewb == 2) {
                auto Vd = Vd_container.as<uint16_t>();
                %(code)s;
            } else if (sewb == 4) {
                auto Vd = Vd_container.as<uint32_t>();
                %(code)s;
            } else if (sewb == 8) {
                auto Vd = Vd_container.as<uint64_t>();
                %(code)s;
            } else {
                std::string error = csprintf(
                    "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                fault = std::make_shared<IllegalInstFault>(error, machInst);
            }

            if (fault == NoFault) {
                if (traceData) {
                    traceData->setData(Vd_container);
                }
            }
        }
        return fault;
    }
}};

def template VectorVRFUNARY0Execute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        softfloat_roundingMode = xc->readMiscReg(MISCREG_FRM);;

        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        uint64_t Fs1_bits = xc->readFloatRegOperandBits(this, 0);
        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, 0);

        if (fault == NoFault) {
            if (sewb == 4) {
                auto Vd = Vd_container.as<uint32_t>();
                %(code)s;
            } else if (sewb == 8) {
                auto Vd = Vd_container.as<uint64_t>();
                %(code)s;
            } else {
                std::string error = csprintf(
                    "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                fault = std::make_shared<IllegalInstFault>(error, machInst);
            }

            if (fault == NoFault) {
                if (traceData) {
                    traceData->setData(Vd_container);
                }
            }
        }
        return fault;
    }
}};

def template VectorVWFUNARY0Execute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        softfloat_roundingMode = xc->readMiscReg(MISCREG_FRM);;

        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, 0);

        uint64_t Fd_bits = 0;

        if (fault == NoFault) {
            %(code)s;

            if (traceData) {
              uint64_t final_val = Fd_bits;
              xc->setFloatRegOperandBits(this, 0, final_val);

              traceData->setData(final_val);
            }
        }
        return fault;
    }
}};

def template VectorVFUNARY0Execute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
             if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorVFUNARY0Op using v0 "
                             "as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
             }
        }

        RegVal FFLAGS = xc->readMiscReg(MISCREG_FFLAGS);
        std::feclearexcept(FE_ALL_EXCEPT);

        for (uint32_t destVecRegID = 0; destVecRegID < _numVecDestRegs; ++destVecRegID) {
            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, destVecRegID);
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, destVecRegID);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID/2];
                        vmask = (vmask >> (destVecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 4) {
                    auto Vd = Vd_container.as<uint32_t>();
                    auto Vs2 = Vs2_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 8) {
                    auto Vd = Vd_container.as<uint64_t>();
                    auto Vs2 = Vs2_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        FFLAGS |= softfloat_exceptionFlags;
        softfloat_exceptionFlags = 0;
        xc->setMiscReg(MISCREG_FFLAGS, FFLAGS);

        return fault;
    }
}};

def template VectorOPIVIExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        if ((VFUNC_6 == 0xe) && (VS2 == VD)) {
            // vslideup cannot have overlapping VS2 and Vd
            std::string error =
                csprintf("vslideup/down cannot have overlapping VS2 and Vd \n");
            return std::make_shared<IllegalInstFault>(error, machInst);
        }

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
             if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorOPIVI using v0 "
                             "as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
             }
        }

        for (uint32_t vecRegID = 0; vecRegID < _numVecDestRegs; ++vecRegID) {
            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, vecRegID);
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, vecRegID);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[vecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[vecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[vecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[vecRegID/2];
                        vmask = (vmask >> (vecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vd = Vd_container.as<uint8_t>();
                    auto Vs2 = Vs2_container.as<uint8_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 2) {
                    auto Vd = Vd_container.as<uint16_t>();
                    auto Vs2 = Vs2_container.as<uint16_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 4) {
                    auto Vd = Vd_container.as<uint32_t>();
                    auto Vs2 = Vs2_container.as<uint32_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 8) {
                    auto Vd = Vd_container.as<uint64_t>();
                    auto Vs2 = Vs2_container.as<uint64_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    fault = std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorVRGatherVIExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        if (VS2 == VD) {
            // vrgather cannot have overlapping VS2 and Vd
            std::string error =
                csprintf("vrgather cannot have overlapping VS2 and Vd \n");
            return std::make_shared<IllegalInstFault>(error, machInst);
        }

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
             if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorOPIVI using v0 "
                             "as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
             }
        }

        uint32_t vlmax = getVlmax(vtype, xc->readMiscReg(MISCREG_VLENB) * 8);
        uint64_t result = 0;
        if (UIMM5 >= vlmax) {
            result = 0;
        } else {
            uint32_t num_elements_per_vs2_reg = (xc->readMiscReg(MISCREG_VLENB) / sewb);
            uint32_t vs2VecRegID = (UIMM5 / num_elements_per_vs2_reg);
            const TheISA::VecRegContainer& Vs2_gather_container = xc->readVecRegOperand(this, vs2VecRegID);

            if (sewb == 1) {
                result = Vs2_gather_container.as<uint8_t>()[UIMM5 % num_elements_per_vs2_reg];
            } else if (sewb == 2) {
                result = Vs2_gather_container.as<uint16_t>()[UIMM5 % num_elements_per_vs2_reg];
            } else if (sewb == 4) {
                result = Vs2_gather_container.as<uint32_t>()[UIMM5 % num_elements_per_vs2_reg];
            } else if (sewb == 8) {
                result = Vs2_gather_container.as<uint64_t>()[UIMM5 % num_elements_per_vs2_reg];
            }
        }

        for (uint32_t vecRegID = 0; vecRegID < _numVecDestRegs; ++vecRegID) {
            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, vecRegID);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[vecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[vecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[vecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[vecRegID/2];
                        vmask = (vmask >> (vecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vd = Vd_container.as<uint8_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 2) {
                    auto Vd = Vd_container.as<uint16_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 4) {
                    auto Vd = Vd_container.as<uint32_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 8) {
                    auto Vd = Vd_container.as<uint64_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    fault = std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorOPIVICarryExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        assert(VM == 0);

        for (uint32_t vecRegID = 0; vecRegID < _numVecDestRegs; ++vecRegID) {
            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, vecRegID);
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, vecRegID);

            uint32_t vmask = UINT32_MAX;
            const TheISA::VecRegContainer& Vmask_container =
                xc->readVecRegOperand(this, _numSrcRegs - 1);
            switch(sewb) {
                case 1:
                    vmask = Vmask_container.as<uint32_t>()[vecRegID];
                    break;
                case 2:
                    vmask = Vmask_container.as<uint16_t>()[vecRegID];
                    break;
                case 4:
                    vmask = Vmask_container.as<uint8_t>()[vecRegID];
                    break;
                case 8:
                    vmask = Vmask_container.as<uint8_t>()[vecRegID/2];
                    vmask = (vmask >> (vecRegID % 2));
                    break;
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vd = Vd_container.as<uint8_t>();
                    auto Vs2 = Vs2_container.as<uint8_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        %(code)s;
                    }
                } else if (sewb == 2) {
                    auto Vd = Vd_container.as<uint16_t>();
                    auto Vs2 = Vs2_container.as<uint16_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        %(code)s;
                    }
                } else if (sewb == 4) {
                    auto Vd = Vd_container.as<uint32_t>();
                    auto Vs2 = Vs2_container.as<uint32_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        %(code)s;
                    }
                } else if (sewb == 8) {
                    auto Vd = Vd_container.as<uint64_t>();
                    auto Vs2 = Vs2_container.as<uint64_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        %(code)s;
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    fault = std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorVdVs2Rs1Execute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        if ((VFUNC_6 == 0xe) && (VS2 == VD)) {
            // vslideup cannot have overlapping VS2 and Vd
            std::string error =
                csprintf("vslideup/down cannot have overlapping VS2 and Vd \n");
            return std::make_shared<IllegalInstFault>(error, machInst);
        }

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
             if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorVdVs2Vs1Op using v0 "
                             "as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
             }
        }

        uint64_t Rs1 = xc->readIntRegOperand(this, 0);
        if (VFUNC_6 != 0xe && VFUNC_6 != 0xf) {
            // For VSLIDEUP/DOWN if XLEN > SEW,
            // OFFSET is not truncated to SEW bits
            Rs1 &= mask(sewb * 8);
        }

        for (uint32_t destVecRegID = 0; destVecRegID < _numVecDestRegs; ++destVecRegID) {
            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, destVecRegID);
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, destVecRegID + 1);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[destVecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[destVecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID/2];
                        vmask = (vmask >> (destVecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vd = Vd_container.as<uint8_t>();
                    auto Vs2 = Vs2_container.as<uint8_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 2) {
                    auto Vd = Vd_container.as<uint16_t>();
                    auto Vs2 = Vs2_container.as<uint16_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 4) {
                    auto Vd = Vd_container.as<uint32_t>();
                    auto Vs2 = Vs2_container.as<uint32_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 8) {
                    auto Vd = Vd_container.as<uint64_t>();
                    auto Vs2 = Vs2_container.as<uint64_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    fault = std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorVRGatherVXExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        if (VS2 == VD) {
            // vrgather cannot have overlapping VS2 and Vd
            std::string error =
                csprintf("vrgather cannot have overlapping VS2 and Vd \n");
            return std::make_shared<IllegalInstFault>(error, machInst);
        }

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
             if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorVdVs2Vs1Op using v0 "
                             "as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
             }
        }

        uint64_t Rs1 =
          xc->readIntRegOperand(this, 0) & mask(sewb * 8);

        uint32_t vlmax = getVlmax(vtype, xc->readMiscReg(MISCREG_VLENB) * 8);
        uint64_t result = 0;
        if (Rs1 >= vlmax) {
            result = 0;
        } else {
            uint32_t num_elements_per_vs2_reg = (xc->readMiscReg(MISCREG_VLENB) / sewb);
            uint32_t vs2VecRegID = (Rs1 / num_elements_per_vs2_reg);
            const TheISA::VecRegContainer& Vs2_gather_container = xc->readVecRegOperand(this, vs2VecRegID + 1);

            if (sewb == 1) {
                result = Vs2_gather_container.as<uint8_t>()[Rs1 % num_elements_per_vs2_reg];
            } else if (sewb == 2) {
                result = Vs2_gather_container.as<uint16_t>()[Rs1 % num_elements_per_vs2_reg];
            } else if (sewb == 4) {
                result = Vs2_gather_container.as<uint32_t>()[Rs1 % num_elements_per_vs2_reg];
            } else if (sewb == 8) {
                result = Vs2_gather_container.as<uint64_t>()[Rs1 % num_elements_per_vs2_reg];
            }
        }

        for (uint32_t destVecRegID = 0; destVecRegID < _numVecDestRegs; ++destVecRegID) {
            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, destVecRegID);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[destVecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[destVecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID/2];
                        vmask = (vmask >> (destVecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vd = Vd_container.as<uint8_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 2) {
                    auto Vd = Vd_container.as<uint16_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 4) {
                    auto Vd = Vd_container.as<uint32_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 8) {
                    auto Vd = Vd_container.as<uint64_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    fault = std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorOPIVXCarryExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
             if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorVdVs2Vs1Op using v0 "
                             "as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
             }
        }

        assert(VM == 0);

        uint64_t Rs1 =
          xc->readIntRegOperand(this, 0) & mask(sewb * 8);

        for (uint32_t destVecRegID = 0; destVecRegID < _numVecDestRegs; ++destVecRegID) {
            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, destVecRegID);
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, destVecRegID + 1);

            uint32_t vmask = UINT32_MAX;
            const TheISA::VecRegContainer& Vmask_container =
                xc->readVecRegOperand(this, _numSrcRegs - 1);
            switch(sewb) {
                case 1:
                    vmask = Vmask_container.as<uint32_t>()[destVecRegID];
                    break;
                case 2:
                    vmask = Vmask_container.as<uint16_t>()[destVecRegID];
                    break;
                case 4:
                    vmask = Vmask_container.as<uint8_t>()[destVecRegID];
                    break;
                case 8:
                    vmask = Vmask_container.as<uint8_t>()[destVecRegID/2];
                    vmask = (vmask >> (destVecRegID % 2));
                    break;
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vd = Vd_container.as<uint8_t>();
                    auto Vs2 = Vs2_container.as<uint8_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        %(code)s;
                    }
                } else if (sewb == 2) {
                    auto Vd = Vd_container.as<uint16_t>();
                    auto Vs2 = Vs2_container.as<uint16_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        %(code)s;
                    }
                } else if (sewb == 4) {
                    auto Vd = Vd_container.as<uint32_t>();
                    auto Vs2 = Vs2_container.as<uint32_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        %(code)s;
                    }
                } else if (sewb == 8) {
                    auto Vd = Vd_container.as<uint64_t>();
                    auto Vs2 = Vs2_container.as<uint64_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        %(code)s;
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    fault = std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorVdVs2Fs1Execute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        softfloat_roundingMode = xc->readMiscReg(MISCREG_FRM);;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VFUNC_6 == 0x17 && VM == 1 && VS2 != 0) {
            // VFMV.V.F must have the vs2 field set to v0.
            std::string error =
                csprintf("Masked VectorVdVs2Vs1Op using v0 "
                            "as src/dst register\n");
            return std::make_shared<IllegalInstFault>(error, machInst);
        }

        if (VM == 0) {
             if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorVdVs2Vs1Op using v0 "
                             "as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
             }
        }

        uint64_t Fs1_bits = xc->readFloatRegOperandBits(this, 0);

        for (uint32_t destVecRegID = 0; destVecRegID < _numVecDestRegs; ++destVecRegID) {
            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, destVecRegID);
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, destVecRegID + 1);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID/2];
                        vmask = (vmask >> (destVecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            RegVal FFLAGS = xc->readMiscReg(MISCREG_FFLAGS);
            std::feclearexcept(FE_ALL_EXCEPT);

            if (sewb == 4) {
                auto Vd = Vd_container.as<uint32_t>();
                auto Vs2_unboxed = Vs2_container.as<uint32_t>();
                auto Vd_unboxed = Vd_container.as<uint32_t>();
                for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                    // VFMERGE.VFM (VFUNC_6 == 0x17) uses the mask to set
                    // the destination register.
                    if (bits(vmask, regElemID, regElemID) == 0 && VFUNC_6 != 0x17) {
                        continue;
                    }

                    %(code)s;
                }
            } else if (sewb == 8) {
                auto Vd = Vd_container.as<uint64_t>();
                auto Vs2_unboxed = Vs2_container.as<uint64_t>();
                auto Vd_unboxed = Vd_container.as<uint64_t>();
                for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                    // VFMERGE.VFM (VFUNC_6 == 0x17) uses the mask to set
                    // the destination register.
                    if (bits(vmask, regElemID, regElemID) == 0 && VFUNC_6 != 0x17) {
                        continue;
                    }

                    %(code)s;
                }
            } else {
                std::string error = csprintf(
                    "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                fault = std::make_shared<IllegalInstFault>(error, machInst);
            }

            FFLAGS |= softfloat_exceptionFlags;
            softfloat_exceptionFlags = 0;
            xc->setMiscReg(MISCREG_FFLAGS, FFLAGS);

            if (fault == NoFault) {
                if (traceData) {
                    traceData->setData(Vd_container);
                }
            }

            vl = vl - num_target_elements_in_reg;
        }

        return fault;
    }
}};

def template VectorVdMaskVs2Rs1Execute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
             if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorVdMaskVs2Rs1 using v0 "
                             "as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
             }
        }

        uint64_t Rs1 =
          xc->readIntRegOperand(this, 0) & mask(sewb * 8);

        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, 0);
        auto Vd_mask = Vd_container.as<VecElem>();

        for (uint32_t destVecRegID = 0; destVecRegID < _numVecSrcRegs; ++destVecRegID) {
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, destVecRegID + 1);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[destVecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[destVecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID/2];
                        vmask = (vmask >> (destVecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vs2 = Vs2_container.as<uint8_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        // If unmasked (vm=1), there is no carry-in or borrow-in.
                        uint32_t carryOrBorrowIn =
                            bits(vmask, regElemID, regElemID) == 1 ? 0 : 0;

                        uint32_t mask_reg_elem_idx =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);
                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 2) {
                    auto Vs2 = Vs2_container.as<uint16_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t carryOrBorrowIn =
                            bits(vmask, regElemID, regElemID) == 1 ? 0 : 0;

                        uint32_t mask_reg_elem_idx =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 4) {
                    auto Vs2 = Vs2_container.as<uint32_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t carryOrBorrowIn =
                            bits(vmask, regElemID, regElemID) == 1 ? 0 : 0;

                        uint32_t mask_reg_elem_idx =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 8) {
                    auto Vs2 = Vs2_container.as<uint64_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t carryOrBorrowIn =
                            bits(vmask, regElemID, regElemID) == 1 ? 0 : 0;

                        uint32_t mask_reg_elem_idx =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    fault = std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorVdMaskOPIVIExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
             if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked OPIVI using v0 "
                             "as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
             }
        }

        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, 0);
        auto Vd_mask = Vd_container.as<VecElem>();

        for (uint32_t destVecRegID = 0; destVecRegID < _numVecSrcRegs; ++destVecRegID) {
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, destVecRegID);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[destVecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[destVecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID/2];
                        vmask = (vmask >> (destVecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vs2 = Vs2_container.as<uint8_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t mask_reg_elem_idx =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);
                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 2) {
                    auto Vs2 = Vs2_container.as<uint16_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t mask_reg_elem_idx =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 4) {
                    auto Vs2 = Vs2_container.as<uint32_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t mask_reg_elem_idx =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 8) {
                    auto Vs2 = Vs2_container.as<uint64_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t mask_reg_elem_idx =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    fault = std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorVdMaskVs2Vs1Execute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
             if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorVdMaskVs2Vs1 using v0 "
                             "as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
             }
        }

        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, 0);
        auto Vd_mask = Vd_container.as<VecElem>();

        for (uint32_t destVecRegID = 0; destVecRegID < _numVecDestRegs; ++destVecRegID) {
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, destVecRegID);
            const TheISA::VecRegContainer& Vs1_container = xc->readVecRegOperand(this, destVecRegID + 1);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[destVecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[destVecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID/2];
                        vmask = (vmask >> (destVecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vs2 = Vs2_container.as<uint8_t>();
                    auto Vs1 = Vs1_container.as<uint8_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        // If unmasked (vm=1), there is no carry-in or borrow-in.
                        uint32_t carryOrBorrowIn =
                            bits(vmask, regElemID, regElemID) == 1 ? 0 : 0;

                        uint32_t mask_reg_elem_idx =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);
                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 2) {
                    auto Vs2 = Vs2_container.as<uint16_t>();
                    auto Vs1 = Vs1_container.as<uint16_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t carryOrBorrowIn =
                            bits(vmask, regElemID, regElemID) == 1 ? 0 : 0;

                        uint32_t mask_reg_elem_idx =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 4) {
                    auto Vs2 = Vs2_container.as<uint32_t>();
                    auto Vs1 = Vs1_container.as<uint32_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t carryOrBorrowIn =
                            bits(vmask, regElemID, regElemID) == 1 ? 0 : 0;

                        uint32_t mask_reg_elem_idx =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 8) {
                    auto Vs2 = Vs2_container.as<uint64_t>();
                    auto Vs1 = Vs1_container.as<uint64_t>();
                    for (size_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t carryOrBorrowIn =
                            bits(vmask, regElemID, regElemID) == 1 ? 0 : 0;

                        uint32_t mask_reg_elem_idx =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    fault = std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorWideningVXExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
            if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorVdVs2Vs1Op using v0 as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        }

        uint64_t Rs1 =
          xc->readIntRegOperand(this, 0) & mask(sewb * 8);

        uint32_t srcVecRegID = 0;
        uint32_t destVecRegID = 0;

        uint32_t srcRegElemID = 0;

        while (vl > 0) {
            uint32_t vmask = UINT32_MAX;
            const TheISA::VecRegContainer& Vmask_container =
                xc->readVecRegOperand(this, _numSrcRegs - 1);

            if (VM == 0) {
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[srcVecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[srcVecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[srcVecRegID];
                        break;
                }
            }

            uint32_t num_elements_in_src_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);
            uint32_t num_elements_in_dst_reg =
                (VecRegSizeBytes/(sewb*2)) > vl ? vl : (VecRegSizeBytes/(sewb*2));

            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, srcVecRegID + 1);

            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, destVecRegID);

            if (sewb == 1) {
                auto Vd = Vd_container.as<uint16_t>();
                auto Vs2 = Vs2_container.as<uint8_t>();

                for (uint32_t destRegElemID = 0; destRegElemID < num_elements_in_dst_reg; ++destRegElemID) {
                    if (bits(vmask, srcRegElemID, srcRegElemID) == 0) {
                        continue;
                    }

                    %(code)s;

                    ++srcRegElemID;
                }
            } else if (sewb == 2) {
                auto Vd = Vd_container.as<uint32_t>();
                auto Vs2 = Vs2_container.as<uint16_t>();

                for (uint32_t destRegElemID = 0; destRegElemID < num_elements_in_dst_reg; ++destRegElemID) {
                    if (bits(vmask, srcRegElemID, srcRegElemID) == 0) {
                        continue;
                    }

                    %(code)s;

                    ++srcRegElemID;
                }
            } else if (sewb == 4) {
                auto Vd = Vd_container.as<uint64_t>();
                auto Vs2 = Vs2_container.as<uint32_t>();

                for (uint32_t destRegElemID = 0; destRegElemID < num_elements_in_dst_reg; ++destRegElemID) {
                    if (bits(vmask, srcRegElemID, srcRegElemID) == 0) {
                        continue;
                    }

                    %(code)s;

                    ++srcRegElemID;
                }
            } else {
                std::string error = csprintf(
                    "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                return std::make_shared<IllegalInstFault>(error, machInst);
            }

            ++destVecRegID;

            vl = vl - num_elements_in_dst_reg;

            if (srcRegElemID == num_elements_in_src_reg) {
                // On to the next src reg.
                srcRegElemID = 0;
                ++srcVecRegID;
            }

            if (fault == NoFault) {
                if (traceData) {
                    traceData->setData(Vd_container);
                }
            }
        }

        return fault;
    }
}};

def template VectorWideningWVExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
            if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorWideningWVOp using v0 as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        }

        uint32_t vs1RegID = 0;
        uint32_t vs2VdRegID = 0;

        uint32_t vs1RegElemID = 0;

        uint32_t numVs1Regs = ceil((float) vl / (VecRegSizeBytes / sewb));

        while (vl > 0) {
            uint32_t vmask = UINT32_MAX;
            const TheISA::VecRegContainer& Vmask_container =
                xc->readVecRegOperand(this, _numSrcRegs - 1);

            if (VM == 0) {
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[vs1RegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[vs1RegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[vs1RegID];
                        break;
                }
            }

            uint32_t num_elements_in_vs1_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);
            uint32_t num_elements_in_vs2Vd_reg =
                (VecRegSizeBytes/(sewb*2)) > vl ? vl : (VecRegSizeBytes/(sewb*2));

            const TheISA::VecRegContainer& Vs1_container = xc->readVecRegOperand(this, vs1RegID);
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, numVs1Regs + vs2VdRegID);

            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, vs2VdRegID);

            if (sewb == 1) {
                auto Vd = Vd_container.as<uint16_t>();
                auto Vs2 = Vs2_container.as<uint16_t>();
                auto Vs1 = Vs1_container.as<uint8_t>();

                for (uint32_t vs2VdRegElemID = 0; vs2VdRegElemID < num_elements_in_vs2Vd_reg; ++vs2VdRegElemID) {
                    if (bits(vmask, vs1RegElemID, vs1RegElemID) == 0) {
                        continue;
                    }

                    %(code)s;

                    ++vs1RegElemID;
                }
            } else if (sewb == 2) {
                auto Vd = Vd_container.as<uint32_t>();
                auto Vs2 = Vs2_container.as<uint32_t>();
                auto Vs1 = Vs1_container.as<uint16_t>();

                for (uint32_t vs2VdRegElemID = 0; vs2VdRegElemID < num_elements_in_vs2Vd_reg; ++vs2VdRegElemID) {
                    if (bits(vmask, vs1RegElemID, vs1RegElemID) == 0) {
                        continue;
                    }

                    %(code)s;

                    ++vs1RegElemID;
                }
            } else if (sewb == 4) {
                auto Vd = Vd_container.as<uint64_t>();
                auto Vs2 = Vs2_container.as<uint64_t>();
                auto Vs1 = Vs1_container.as<uint32_t>();

                for (uint32_t vs2VdRegElemID = 0; vs2VdRegElemID < num_elements_in_vs2Vd_reg; ++vs2VdRegElemID) {
                    if (bits(vmask, vs1RegElemID, vs1RegElemID) == 0) {
                        continue;
                    }

                    %(code)s;

                    ++vs1RegElemID;
                }
            } else {
                std::string error = csprintf(
                    "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                return std::make_shared<IllegalInstFault>(error, machInst);
            }

            ++vs2VdRegID;

            vl = vl - num_elements_in_vs2Vd_reg;

            if (vs1RegElemID == num_elements_in_vs1_reg) {
                // On to the next src reg.
                vs1RegElemID = 0;
                ++vs1RegID;
            }

            if (fault == NoFault) {
                if (traceData) {
                    traceData->setData(Vd_container);
                }
            }
        }

        return fault;
    }
}};

def template VectorWideningVVExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
            if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorWideningVVOp using v0 as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        }

        uint32_t srcVecRegID = 0;
        uint32_t destVecRegID = 0;

        uint32_t srcRegElemID = 0;

        uint32_t numVs2Regs = ceil((float) vl / (VecRegSizeBytes / sewb));

        while (vl > 0) {
            uint32_t vmask = UINT32_MAX;
            const TheISA::VecRegContainer& Vmask_container =
                xc->readVecRegOperand(this, _numSrcRegs - 1);

            if (VM == 0) {
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[srcVecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[srcVecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[srcVecRegID];
                        break;
                }
            }

            uint32_t num_elements_in_src_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);
            uint32_t num_elements_in_dst_reg =
                (VecRegSizeBytes/(sewb*2)) > vl ? vl : (VecRegSizeBytes/(sewb*2));

            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, srcVecRegID);
            const TheISA::VecRegContainer& Vs1_container = xc->readVecRegOperand(this, numVs2Regs + srcVecRegID);

            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, destVecRegID);

            if (sewb == 1) {
                auto Vd = Vd_container.as<uint16_t>();
                auto Vs2 = Vs2_container.as<uint8_t>();
                auto Vs1 = Vs1_container.as<uint8_t>();

                for (uint32_t destRegElemID = 0; destRegElemID < num_elements_in_dst_reg; ++destRegElemID) {
                    if (bits(vmask, srcRegElemID, srcRegElemID) == 0) {
                        continue;
                    }

                    %(code)s;

                    ++srcRegElemID;
                }
            } else if (sewb == 2) {
                auto Vd = Vd_container.as<uint32_t>();
                auto Vs2 = Vs2_container.as<uint16_t>();
                auto Vs1 = Vs1_container.as<uint16_t>();

                for (uint32_t destRegElemID = 0; destRegElemID < num_elements_in_dst_reg; ++destRegElemID) {
                    if (bits(vmask, srcRegElemID, srcRegElemID) == 0) {
                        continue;
                    }

                    %(code)s;

                    ++srcRegElemID;
                }
            } else if (sewb == 4) {
                auto Vd = Vd_container.as<uint64_t>();
                auto Vs2 = Vs2_container.as<uint32_t>();
                auto Vs1 = Vs1_container.as<uint32_t>();

                for (uint32_t destRegElemID = 0; destRegElemID < num_elements_in_dst_reg; ++destRegElemID) {
                    if (bits(vmask, srcRegElemID, srcRegElemID) == 0) {
                        continue;
                    }

                    %(code)s;

                    ++srcRegElemID;
                }
            } else {
                std::string error = csprintf(
                    "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                return std::make_shared<IllegalInstFault>(error, machInst);
            }

            ++destVecRegID;

            vl = vl - num_elements_in_dst_reg;

            if (srcRegElemID == num_elements_in_src_reg) {
                // On to the next src reg.
                srcRegElemID = 0;
                ++srcVecRegID;
            }

            if (fault == NoFault) {
                if (traceData) {
                    traceData->setData(Vd_container);
                }
            }
        }

        return fault;
    }
}};

def template VectorWideningFPReductionExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        softfloat_roundingMode = xc->readMiscReg(MISCREG_FRM);;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        assert(sewb == 4);

        if (VM == 0) {
            if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorWideningFPReduction using v0 as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        }

        RegVal FFLAGS = xc->readMiscReg(MISCREG_FFLAGS);
        std::feclearexcept(FE_ALL_EXCEPT);

        uint32_t srcVecRegID = 0;
        uint32_t srcRegElemID = 0;

        // The reduction instructions operate on Vd[0], Vs1[0] and all of Vs2.
        TheISA::VecRegContainer& Vd_0_container = xc->getWritableVecRegOperand(this, 0);
        auto Vd0 = Vd_0_container.as<uint64_t>();

        const TheISA::VecRegContainer& Vs1_0_container = xc->readVecRegOperand(this, 0);
        auto Vs1_0 = Vs1_0_container.as<uint64_t>();

        uint32_t vmask = UINT32_MAX;
        const TheISA::VecRegContainer& Vmask_container =
            xc->readVecRegOperand(this, _numSrcRegs - 1);

        for (uint32_t srcVecRegID = 0; srcVecRegID < _numVecSrcRegs; ++srcVecRegID) {
            if (VM == 0) {
                vmask = Vmask_container.as<uint8_t>()[srcVecRegID];
                break;
            }

            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, srcVecRegID);
            auto Vs2 = Vs2_container.as<uint32_t>();

            uint32_t num_elements_in_src_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            for (uint32_t srcRegElemID = 0; srcRegElemID < num_elements_in_src_reg; ++srcRegElemID) {
                if (bits(vmask, srcRegElemID, srcRegElemID) == 0) {
                    continue;
                }

                %(code)s;
            }
        }

        FFLAGS |= softfloat_exceptionFlags;
        softfloat_exceptionFlags = 0;
        xc->setMiscReg(MISCREG_FFLAGS, FFLAGS);

        if (fault == NoFault) {
            if (traceData) {
                traceData->setData(Vd_0_container);
            }
        }

        return fault;
    }
}};

def template VectorSingleWidthIntegerReductionExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
            if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorSingleWidthIntegerReduction using v0 as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        }

        uint32_t numVs2Regs = ceil((float) vl / (VecRegSizeBytes / sewb));

        uint32_t vs2RegID = 0;

        // The reduction instructions operate on Vd[0], Vs1[0] and all of Vs2.
        __uint128_t result = 0;
        const TheISA::VecRegContainer& Vs1_0_container = xc->readVecRegOperand(this, 0);

        for (uint32_t vs2RegID = 0; vs2RegID < numVs2Regs; ++vs2RegID) {
            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[vs2RegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[vs2RegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[vs2RegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[vs2RegID/2];
                        vmask = (vmask >> (vs2RegID % 2));
                        break;
                }
            }

            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, vs2RegID + 1);

            uint32_t num_elements_in_src_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (sewb == 1) {
                auto Vs1_0 = Vs1_0_container.as<uint8_t>();
                auto Vs2 = Vs2_container.as<uint8_t>();

                for (uint32_t vs2RegElemID = 0; vs2RegElemID < num_elements_in_src_reg; ++vs2RegElemID) {
                    if (vs2RegID == 0 && vs2RegElemID == 0) {
                        result = Vs1_0[0];
                    }

                    if (bits(vmask, vs2RegElemID, vs2RegElemID) == 0) {
                        continue;
                    }

                    %(code)s;
                }
            } else if (sewb == 2) {
                auto Vs1_0 = Vs1_0_container.as<uint16_t>();
                auto Vs2 = Vs2_container.as<uint16_t>();

                for (uint32_t vs2RegElemID = 0; vs2RegElemID < num_elements_in_src_reg; ++vs2RegElemID) {
                    if (vs2RegID == 0 && vs2RegElemID == 0) {
                        result = Vs1_0[0];
                    }

                    if (bits(vmask, vs2RegElemID, vs2RegElemID) == 0) {
                        continue;
                    }

                    %(code)s;
                }
            } else if (sewb == 4) {
                auto Vs1_0 = Vs1_0_container.as<uint32_t>();
                auto Vs2 = Vs2_container.as<uint32_t>();

                for (uint32_t vs2RegElemID = 0; vs2RegElemID < num_elements_in_src_reg; ++vs2RegElemID) {
                    if (vs2RegID == 0 && vs2RegElemID == 0) {
                        result = Vs1_0[0];
                    }

                    if (bits(vmask, vs2RegElemID, vs2RegElemID) == 0) {
                        continue;
                    }

                    %(code)s;
                }
            } else if (sewb == 8) {
                auto Vs1_0 = Vs1_0_container.as<uint64_t>();
                auto Vs2 = Vs2_container.as<uint64_t>();

                for (uint32_t vs2RegElemID = 0; vs2RegElemID < num_elements_in_src_reg; ++vs2RegElemID) {
                    if (vs2RegID == 0 && vs2RegElemID == 0) {
                        result = Vs1_0[0];
                    }

                    if (bits(vmask, vs2RegElemID, vs2RegElemID) == 0) {
                        continue;
                    }

                    %(code)s;
                }
            } else {
                std::string error = csprintf(
                    "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        }

        TheISA::VecRegContainer& Vd_0_container = xc->getWritableVecRegOperand(this, 0);
        if (sewb == 1) {
            auto Vd0 = Vd_0_container.as<uint8_t>();
            Vd0[0] = result & mask(sewb * 8);
        } else if (sewb == 2) {
            auto Vd0 = Vd_0_container.as<uint16_t>();
            Vd0[0] = result & mask(sewb * 8);
        } else if (sewb == 4) {
            auto Vd0 = Vd_0_container.as<uint32_t>();
            Vd0[0] = result & mask(sewb * 8);
        } else if (sewb == 8) {
            auto Vd0 = Vd_0_container.as<uint64_t>();
            Vd0[0] = result & mask(sewb * 8);
        }

        if (fault == NoFault) {
            if (traceData) {
                traceData->setData(Vd_0_container);
            }
        }

        return fault;
    }
}};

def template VectorWideningVdVs2Execute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
            if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorVdVs2Vs1Op using v0 as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        }

        uint32_t srcVecRegID = 0;
        uint32_t destVecRegID = 0;

        uint32_t srcRegElemID = 0;

        assert(sewb == 4);

        while (vl > 0) {
            uint32_t vmask = UINT32_MAX;
            const TheISA::VecRegContainer& Vmask_container =
                xc->readVecRegOperand(this, _numSrcRegs - 1);

            if (VM == 0) {
                vmask = Vmask_container.as<uint8_t>()[srcVecRegID];
                break;
            }

            uint32_t num_elements_in_src_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);
            uint32_t num_elements_in_dst_reg =
                (VecRegSizeBytes/(sewb*2)) > vl ? vl : (VecRegSizeBytes/(sewb*2));

            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, srcVecRegID);

            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, destVecRegID);

            auto Vd = Vd_container.as<uint64_t>();
            auto Vs2 = Vs2_container.as<uint32_t>();

            for (uint32_t destRegElemID = 0; destRegElemID < num_elements_in_dst_reg; ++destRegElemID) {
                if (bits(vmask, srcRegElemID, srcRegElemID) == 0) {
                    continue;
                }

                %(code)s;

                ++srcRegElemID;
            }

            ++destVecRegID;

            vl = vl - num_elements_in_dst_reg;

            if (srcRegElemID == num_elements_in_src_reg) {
                // On to the next src reg.
                srcRegElemID = 0;
                ++srcVecRegID;
            }

            if (fault == NoFault) {
                if (traceData) {
                    traceData->setData(Vd_container);
                }
            }
        }

        return fault;
    }
}};

def template VectorWideningVdFs1Vs2Execute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        softfloat_roundingMode = xc->readMiscReg(MISCREG_FRM);;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        assert(sewb == 4);

        if (VM == 0) {
            if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorVdVs2Vs1Op using v0 as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        }

        uint64_t Fs1_bits = xc->readFloatRegOperandBits(this, 0);

        uint32_t srcVecRegID = 0;
        uint32_t destVecRegID = 0;

        uint32_t srcRegElemID = 0;

        while (vl > 0) {
            uint32_t vmask = UINT32_MAX;
            const TheISA::VecRegContainer& Vmask_container =
                xc->readVecRegOperand(this, _numSrcRegs - 1);

            if (VM == 0) {
                vmask = Vmask_container.as<uint16_t>()[srcVecRegID];
            }

            uint32_t num_elements_in_src_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);
            uint32_t num_elements_in_dst_reg =
                (VecRegSizeBytes/(sewb*2)) > vl ? vl : (VecRegSizeBytes/(sewb*2));

            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, srcVecRegID + 1);

            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, destVecRegID);

            auto Vd = Vd_container.as<uint64_t>();

            for (uint32_t destRegElemID = 0; destRegElemID < num_elements_in_dst_reg; ++destRegElemID) {
                if (bits(vmask, srcRegElemID, srcRegElemID) == 0) {
                    continue;
                }

                RegVal FFLAGS = xc->readMiscReg(MISCREG_FFLAGS);
                std::feclearexcept(FE_ALL_EXCEPT);

                %(code)s;

                FFLAGS |= softfloat_exceptionFlags;
                softfloat_exceptionFlags = 0;
                xc->setMiscReg(MISCREG_FFLAGS, FFLAGS);

                ++srcRegElemID;
            }

            ++destVecRegID;

            vl = vl - num_elements_in_dst_reg;

            if (srcRegElemID == num_elements_in_src_reg) {
                // On to the next src reg.
                srcRegElemID = 0;
                ++srcVecRegID;
            }

            if (fault == NoFault) {
                if (traceData) {
                    traceData->setData(Vd_container);
                }
            }
        }

        return fault;
    }
}};

def template VectorNarrowingVVExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
            if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorVdVs2Vs1Op using v0 as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        }

        uint32_t Vs2RegID = 0;
        uint32_t VdV1RegID = 0;

        uint32_t VdVs1ElemID = 0;

        uint32_t numVs1Regs = _numVecDestRegs;

        while (vl > 0) {
            uint32_t vmask = UINT32_MAX;
            const TheISA::VecRegContainer& Vmask_container =
                xc->readVecRegOperand(this, _numSrcRegs - 1);

            if (VM == 0) {
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[VdV1RegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[VdV1RegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[VdV1RegID];
                        break;
                }
            }

            uint32_t num_elements_in_VdVs1 =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);
            uint32_t num_elements_in_Vs2 =
                (VecRegSizeBytes/(sewb*2)) > vl ? vl : (VecRegSizeBytes/(sewb*2));

            const TheISA::VecRegContainer& Vs1_container = xc->readVecRegOperand(this, VdV1RegID);
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, Vs2RegID + numVs1Regs);
            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, VdV1RegID);

            if (sewb == 1) {
                auto Vd = Vd_container.as<uint8_t>();
                auto Vs1 = Vs1_container.as<uint8_t>();
                auto Vs2 = Vs2_container.as<uint16_t>();

                for (uint32_t Vs2ElemID = 0; Vs2ElemID < num_elements_in_Vs2; ++Vs2ElemID) {
                    if (bits(vmask, VdVs1ElemID, VdVs1ElemID) == 1) {
                        %(code)s;
                    }

                    ++VdVs1ElemID;
                }
            } else if (sewb == 2) {
                auto Vd = Vd_container.as<uint16_t>();
                auto Vs1 = Vs1_container.as<uint16_t>();
                auto Vs2 = Vs2_container.as<uint32_t>();

                for (uint32_t Vs2ElemID = 0; Vs2ElemID < num_elements_in_Vs2; ++Vs2ElemID) {
                    if (bits(vmask, VdVs1ElemID, VdVs1ElemID) == 1) {
                        %(code)s;
                    }

                    ++VdVs1ElemID;
                }
            } else if (sewb == 4) {
                auto Vd = Vd_container.as<uint32_t>();
                auto Vs1 = Vs1_container.as<uint32_t>();
                auto Vs2 = Vs2_container.as<uint64_t>();

                for (uint32_t Vs2ElemID = 0; Vs2ElemID < num_elements_in_Vs2; ++Vs2ElemID) {
                    if (bits(vmask, VdVs1ElemID, VdVs1ElemID) == 1) {
                        %(code)s;
                    }

                    ++VdVs1ElemID;
                }
            } else {
                std::string error = csprintf(
                    "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                return std::make_shared<IllegalInstFault>(error, machInst);
            }

            ++Vs2RegID;

            vl = vl - num_elements_in_Vs2;

            if (VdVs1ElemID == num_elements_in_VdVs1) {
                // On to the next Vs1 and Vd regs.
                VdVs1ElemID = 0;
                ++VdV1RegID;
            }

            if (fault == NoFault) {
                if (traceData) {
                    traceData->setData(Vd_container);
                }
            }
        }

        return fault;
    }
}};

def template VectorNarrowingVIExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
            if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorNarrowingVIOp using v0 as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        }

        uint32_t Vs2RegID = 0;
        uint32_t VdRegID = 0;

        uint32_t VdElemID = 0;

        while (vl > 0) {
            uint32_t vmask = UINT32_MAX;
            const TheISA::VecRegContainer& Vmask_container =
                xc->readVecRegOperand(this, _numSrcRegs - 1);

            if (VM == 0) {
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[VdRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[VdRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[VdRegID];
                        break;
                }
            }

            uint32_t num_elements_in_Vd =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);
            uint32_t num_elements_in_Vs2 =
                (VecRegSizeBytes/(sewb*2)) > vl ? vl : (VecRegSizeBytes/(sewb*2));

            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, VdRegID);
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, Vs2RegID);

            if (sewb == 1) {
                auto Vd = Vd_container.as<uint8_t>();
                auto Vs2 = Vs2_container.as<uint16_t>();

                for (uint32_t Vs2ElemID = 0; Vs2ElemID < num_elements_in_Vs2; ++Vs2ElemID) {
                    if (bits(vmask, VdElemID, VdElemID) == 1) {
                        %(code)s;
                    }

                    ++VdElemID;
                }
            } else if (sewb == 2) {
                auto Vd = Vd_container.as<uint16_t>();
                auto Vs2 = Vs2_container.as<uint32_t>();

                for (uint32_t Vs2ElemID = 0; Vs2ElemID < num_elements_in_Vs2; ++Vs2ElemID) {
                    if (bits(vmask, VdElemID, VdElemID) == 1) {
                        %(code)s;
                    }

                    ++VdElemID;
                }
            } else if (sewb == 4) {
                auto Vd = Vd_container.as<uint32_t>();
                auto Vs2 = Vs2_container.as<uint64_t>();

                for (uint32_t Vs2ElemID = 0; Vs2ElemID < num_elements_in_Vs2; ++Vs2ElemID) {
                    if (bits(vmask, VdElemID, VdElemID) == 1) {
                        %(code)s;
                    }

                    ++VdElemID;
                }
            } else {
                std::string error = csprintf(
                    "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                return std::make_shared<IllegalInstFault>(error, machInst);
            }

            ++Vs2RegID;

            vl = vl - num_elements_in_Vs2;

            if (VdElemID == num_elements_in_Vd) {
                // On to the next Vd reg.
                VdElemID = 0;
                ++VdRegID;
            }

            if (fault == NoFault) {
                if (traceData) {
                    traceData->setData(Vd_container);
                }
            }
        }

        return fault;
    }
}};

def template VectorNarrowingWXExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
            if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorNarrowingWXOp using v0 as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        }

        uint32_t Vs2RegID = 0;
        uint32_t VdRegID = 0;

        uint32_t VdElemID = 0;

        uint64_t Rs1 =
            xc->readIntRegOperand(this, 0) & mask(sewb * 8);

        while (vl > 0) {
            uint32_t vmask = UINT32_MAX;
            const TheISA::VecRegContainer& Vmask_container =
                xc->readVecRegOperand(this, _numSrcRegs - 1);

            if (VM == 0) {
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[VdRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[VdRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[VdRegID];
                        break;
                }
            }

            uint32_t num_elements_in_Vd =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);
            uint32_t num_elements_in_Vs2 =
                (VecRegSizeBytes/(sewb*2)) > vl ? vl : (VecRegSizeBytes/(sewb*2));

            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, VdRegID);
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, Vs2RegID + 1);

            if (sewb == 1) {
                auto Vd = Vd_container.as<uint8_t>();
                auto Vs2 = Vs2_container.as<uint16_t>();

                for (uint32_t Vs2ElemID = 0; Vs2ElemID < num_elements_in_Vs2; ++Vs2ElemID) {
                    if (bits(vmask, VdElemID, VdElemID) == 1) {
                        %(code)s;
                    }

                    ++VdElemID;
                }
            } else if (sewb == 2) {
                auto Vd = Vd_container.as<uint16_t>();
                auto Vs2 = Vs2_container.as<uint32_t>();

                for (uint32_t Vs2ElemID = 0; Vs2ElemID < num_elements_in_Vs2; ++Vs2ElemID) {
                    if (bits(vmask, VdElemID, VdElemID) == 1) {
                        %(code)s;
                    }

                    ++VdElemID;
                }
            } else if (sewb == 4) {
                auto Vd = Vd_container.as<uint32_t>();
                auto Vs2 = Vs2_container.as<uint64_t>();

                for (uint32_t Vs2ElemID = 0; Vs2ElemID < num_elements_in_Vs2; ++Vs2ElemID) {
                    if (bits(vmask, VdElemID, VdElemID) == 1) {
                        %(code)s;
                    }

                    ++VdElemID;
                }
            } else {
                std::string error = csprintf(
                    "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                return std::make_shared<IllegalInstFault>(error, machInst);
            }

            ++Vs2RegID;

            vl = vl - num_elements_in_Vs2;

            if (VdElemID == num_elements_in_Vd) {
                // On to the next Vd reg.
                VdElemID = 0;
                ++VdRegID;
            }

            if (fault == NoFault) {
                if (traceData) {
                    traceData->setData(Vd_container);
                }
            }
        }

        return fault;
    }
}};

def template VectorIntegerExtensionExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        if (VD == VS2) {
            std::string error =
                csprintf("Vector Integer Extension instruction cannot have overlapping VS2 and Vd \n");
            return std::make_shared<IllegalInstFault>(error, machInst);
        }

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
            if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorIntegerExtensionOp using v0 as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        }

        uint32_t divisor = 0;
        switch(RS1) {
            case 2:
            case 3:
                divisor = 8;
                break;
            case 4:
            case 5:
                divisor = 4;
                break;
            case 6:
            case 7:
                divisor = 2;
                break;
        }

        uint32_t eewb = sewb / divisor;
        assert(eewb > 0);

        uint32_t Vs2RegID = 0;
        uint32_t VdRegID = 0;

        uint32_t VdElemID = 0;

        while (vl > 0) {
            uint32_t vmask = UINT32_MAX;
            const TheISA::VecRegContainer& Vmask_container =
                xc->readVecRegOperand(this, _numSrcRegs - 1);

            if (VM == 0) {
                switch(eewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[Vs2RegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[Vs2RegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[Vs2RegID];
                        break;
                }
            }

            uint32_t num_elements_in_Vd =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);
            uint32_t num_elements_in_Vs2 =
                (VecRegSizeBytes/eewb) > vl ? vl : (VecRegSizeBytes/eewb);

            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, VdRegID);
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, Vs2RegID);

            if (sewb == 8) {
                if (eewb == 4) {
                    auto Vs2 = Vs2_container.as<uint32_t>();

                    for (uint32_t Vs2ElemID = 0; Vs2ElemID < num_elements_in_Vs2; ++Vs2ElemID) {
                        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, VdRegID);
                        auto Vd = Vd_container.as<uint64_t>();
                        if (bits(vmask, VdElemID, VdElemID) == 1) {
                            %(code)s;
                        }

                        ++VdElemID;
                        if (VdElemID == num_elements_in_Vd) {
                            // On to the next Vd reg.
                            VdElemID = 0;
                            ++VdRegID;
                        }
                    }
                } else if (eewb == 2) {
                    auto Vs2 = Vs2_container.as<uint16_t>();

                    for (uint32_t Vs2ElemID = 0; Vs2ElemID < num_elements_in_Vs2; ++Vs2ElemID) {
                        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, VdRegID);
                        auto Vd = Vd_container.as<uint64_t>();
                        if (bits(vmask, VdElemID, VdElemID) == 1) {
                            %(code)s;
                        }

                        ++VdElemID;
                        if (VdElemID == num_elements_in_Vd) {
                            // On to the next Vd reg.
                            VdElemID = 0;
                            ++VdRegID;
                        }
                    }
                } else if (eewb == 1) {
                    auto Vs2 = Vs2_container.as<uint8_t>();

                    for (uint32_t Vs2ElemID = 0; Vs2ElemID < num_elements_in_Vs2; ++Vs2ElemID) {
                        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, VdRegID);
                        auto Vd = Vd_container.as<uint64_t>();

                        if (bits(vmask, VdElemID, VdElemID) == 1) {
                            %(code)s;
                        }

                        ++VdElemID;
                        if (VdElemID == num_elements_in_Vd) {
                            // On to the next Vd reg.
                            VdElemID = 0;
                            ++VdRegID;
                        }
                    }
                }
            } else if (sewb == 4) {
                if (eewb == 2) {
                    auto Vs2 = Vs2_container.as<uint16_t>();

                    for (uint32_t Vs2ElemID = 0; Vs2ElemID < num_elements_in_Vs2; ++Vs2ElemID) {
                        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, VdRegID);
                        auto Vd = Vd_container.as<uint32_t>();

                        if (bits(vmask, VdElemID, VdElemID) == 1) {
                            %(code)s;
                        }

                        ++VdElemID;
                        if (VdElemID == num_elements_in_Vd) {
                            // On to the next Vd reg.
                            VdElemID = 0;
                            ++VdRegID;
                        }
                    }
                } else if (eewb == 1) {
                    auto Vs2 = Vs2_container.as<uint8_t>();

                    for (uint32_t Vs2ElemID = 0; Vs2ElemID < num_elements_in_Vs2; ++Vs2ElemID) {
                        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, VdRegID);
                        auto Vd = Vd_container.as<uint32_t>();

                        if (bits(vmask, VdElemID, VdElemID) == 1) {
                            %(code)s;
                        }

                        ++VdElemID;
                        if (VdElemID == num_elements_in_Vd) {
                            // On to the next Vd reg.
                            VdElemID = 0;
                            ++VdRegID;
                        }
                    }
                }
            } else if (sewb == 2) {
                if (eewb == 1) {
                    auto Vs2 = Vs2_container.as<uint8_t>();

                    for (uint32_t Vs2ElemID = 0; Vs2ElemID < num_elements_in_Vs2; ++Vs2ElemID) {
                        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, VdRegID);
                        auto Vd = Vd_container.as<uint16_t>();

                        if (bits(vmask, VdElemID, VdElemID) == 1) {
                            %(code)s;
                        }

                        ++VdElemID;
                        if (VdElemID == num_elements_in_Vd) {
                            // On to the next Vd reg.
                            VdElemID = 0;
                            ++VdRegID;
                        }
                    }
                }
            } else {
                std::string error = csprintf(
                    "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                return std::make_shared<IllegalInstFault>(error, machInst);
            }

            ++Vs2RegID;

            vl = vl - num_elements_in_Vs2;

            if (traceData) {
                traceData->setData(Vd_container);
            }
        }

        return fault;
    }
}};

def template VectorMaskRegisterVdVs2Vs1Execute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);

        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, 0);
        const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, 0);
        const TheISA::VecRegContainer& Vs1_container = xc->readVecRegOperand(this, 1);

        auto Vd_mask = Vd_container.as<uint64_t>();
        auto Vs2_mask = Vs2_container.as<uint64_t>();
        auto Vs1_mask = Vs1_container.as<uint64_t>();

        size_t num_64_bit_elements_in_reg = (VecRegSizeBytes / (sizeof(uint64_t)));

        for (uint32_t regElemID = 0; regElemID < num_64_bit_elements_in_reg; ++regElemID) {
            for (uint32_t maskBitPosition = 0; maskBitPosition < 64; maskBitPosition++) {
                uint8_t Vs1_mask_bit = bits(Vs1_mask[regElemID], maskBitPosition, maskBitPosition);
                uint8_t Vs2_mask_bit = bits(Vs2_mask[regElemID], maskBitPosition, maskBitPosition);
                %(code)s;

                Vd_mask[regElemID] &= ~(1 << maskBitPosition);
                Vd_mask[regElemID] |= (uint64_t) result << maskBitPosition;

                --vl;
                if (vl == 0) {
                    break;
                }
            }
            if (vl == 0) {
                break;
            }
        }

        if (fault == NoFault) {
            if (traceData) {
                traceData->setData(Vd_container);
            }
        }

        return fault;
    }
}};

def template VectorMaskRegisterVdVs2Execute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        if (VS2 == VD) {
            std::string error =
                csprintf("Vector Mask Instructions cannot have overlapping VS2 and Vd \n");
            return std::make_shared<IllegalInstFault>(error, machInst);
        }

        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        uint32_t vmask = UINT32_MAX;
        if (VM == 0) {
            const TheISA::VecRegContainer& Vmask_container =
                xc->readVecRegOperand(this, _numSrcRegs - 1);
            vmask = Vmask_container.as<uint32_t>()[0];
        }

        const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, 0);
        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, 0);

        if (fault == NoFault) {
            auto Vs2 = Vs2_container.as<uint32_t>();
            auto Vd = Vd_container.as<uint32_t>();
            %(code)s;

            if (fault == NoFault) {
                if (traceData) {
                    traceData->setData(Vd_container);
                }
            }
        }
        return fault;
    }
}};

def template VectorWholeRegisterMoveExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        size_t num_64_bit_elements_in_reg = (VecRegSizeBytes / (sizeof(uint64_t)));

        for (uint32_t regID = 0; regID < _numVecDestRegs; ++regID) {
            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, regID);
            auto Vd = Vd_container.as<uint64_t>();

            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, regID);
            auto Vs2 = Vs2_container.as<uint64_t>();

            for (uint32_t regElemID = 0; regElemID < num_64_bit_elements_in_reg; regElemID++) {
                %(code)s;
            }

            if (fault == NoFault) {
                if (traceData) {
                    traceData->setData(Vd_container);
                }
            }
        }

        return fault;
    }
}};

def template VectorOPFVVOpExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
             if (VD == 0 || VS1 == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorVdVs2Vs1Op using v0 "
                             "as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
             }
        }

        RegVal FFLAGS = xc->readMiscReg(MISCREG_FFLAGS);
        std::feclearexcept(FE_ALL_EXCEPT);

        for (uint32_t destVecRegID = 0; destVecRegID < _numVecDestRegs; ++destVecRegID) {
            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, destVecRegID);
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, destVecRegID);
            const TheISA::VecRegContainer& Vs1_container = xc->readVecRegOperand(this, _numVecDestRegs + destVecRegID);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[destVecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[destVecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID/2];
                        vmask = (vmask >> (destVecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vd = Vd_container.as<uint8_t>();
                    auto Vs2 = Vs2_container.as<uint8_t>();
                    auto Vs1 = Vs1_container.as<uint8_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 2) {
                    auto Vd = Vd_container.as<uint16_t>();
                    auto Vs2 = Vs2_container.as<uint16_t>();
                    auto Vs1 = Vs1_container.as<uint16_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 4) {
                    auto Vd = Vd_container.as<uint32_t>();
                    auto Vs2 = Vs2_container.as<uint32_t>();
                    auto Vs1 = Vs1_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 8) {
                    auto Vd = Vd_container.as<uint64_t>();
                    auto Vs2 = Vs2_container.as<uint64_t>();
                    auto Vs1 = Vs1_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        FFLAGS |= softfloat_exceptionFlags;
        softfloat_exceptionFlags = 0;
        xc->setMiscReg(MISCREG_FFLAGS, FFLAGS);

        return fault;
    }
}};

def template VectorVdVs2Vs1OpExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
             if (VD == 0 || VS1 == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorVdVs2Vs1Op using v0 "
                             "as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
             }
        }

        RegVal FFLAGS = xc->readMiscReg(MISCREG_FFLAGS);
        std::feclearexcept(FE_ALL_EXCEPT);

        for (uint32_t destVecRegID = 0; destVecRegID < _numVecDestRegs; ++destVecRegID) {
            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, destVecRegID);
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, destVecRegID);
            const TheISA::VecRegContainer& Vs1_container = xc->readVecRegOperand(this, _numVecDestRegs + destVecRegID);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[destVecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[destVecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID/2];
                        vmask = (vmask >> (destVecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vd = Vd_container.as<uint8_t>();
                    auto Vs2 = Vs2_container.as<uint8_t>();
                    auto Vs1 = Vs1_container.as<uint8_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 2) {
                    auto Vd = Vd_container.as<uint16_t>();
                    auto Vs2 = Vs2_container.as<uint16_t>();
                    auto Vs1 = Vs1_container.as<uint16_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 4) {
                    auto Vd = Vd_container.as<uint32_t>();
                    auto Vs2 = Vs2_container.as<uint32_t>();
                    auto Vs1 = Vs1_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 8) {
                    auto Vd = Vd_container.as<uint64_t>();
                    auto Vs2 = Vs2_container.as<uint64_t>();
                    auto Vs1 = Vs1_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        FFLAGS |= softfloat_exceptionFlags;
        softfloat_exceptionFlags = 0;
        xc->setMiscReg(MISCREG_FFLAGS, FFLAGS);

        return fault;
    }
}};

def template VectorVRGatherVVOpExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        if (VS2 == VD || VD == VS1) {
            // vrgather cannot have overlapping VS2 and Vd
            std::string error =
                csprintf("vrgather cannot have overlapping VS2 and Vd \n");
            return std::make_shared<IllegalInstFault>(error, machInst);
        }

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
             if (VD == 0 || VS1 == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorVdVs2Vs1Op using v0 "
                             "as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
             }
        }

        for (uint32_t destVecRegID = 0; destVecRegID < _numVecDestRegs; ++destVecRegID) {
            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, destVecRegID);
            const TheISA::VecRegContainer& Vs1_container = xc->readVecRegOperand(this, _numVecDestRegs + destVecRegID);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[destVecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[destVecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID/2];
                        vmask = (vmask >> (destVecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vd = Vd_container.as<uint8_t>();
                    auto Vs1 = Vs1_container.as<uint8_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 2) {
                    auto Vd = Vd_container.as<uint16_t>();
                    auto Vs1 = Vs1_container.as<uint16_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 4) {
                    auto Vd = Vd_container.as<uint32_t>();
                    auto Vs1 = Vs1_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else if (sewb == 8) {
                    auto Vd = Vd_container.as<uint64_t>();
                    auto Vs1 = Vs1_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        %(code)s;
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorOPIVVCarryExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        assert(VM == 0);

        for (uint32_t destVecRegID = 0; destVecRegID < _numVecDestRegs; ++destVecRegID) {
            TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, destVecRegID);
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, destVecRegID);
            const TheISA::VecRegContainer& Vs1_container = xc->readVecRegOperand(this, _numVecDestRegs + destVecRegID);

            uint32_t vmask = UINT32_MAX;
            const TheISA::VecRegContainer& Vmask_container =
                xc->readVecRegOperand(this, _numSrcRegs - 1);
            switch(sewb) {
                case 1:
                    vmask = Vmask_container.as<uint32_t>()[destVecRegID];
                    break;
                case 2:
                    vmask = Vmask_container.as<uint16_t>()[destVecRegID];
                    break;
                case 4:
                    vmask = Vmask_container.as<uint8_t>()[destVecRegID];
                    break;
                case 8:
                    vmask = Vmask_container.as<uint8_t>()[destVecRegID/2];
                    vmask = (vmask >> (destVecRegID % 2));
                    break;
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vd = Vd_container.as<uint8_t>();
                    auto Vs2 = Vs2_container.as<uint8_t>();
                    auto Vs1 = Vs1_container.as<uint8_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        %(code)s;
                    }
                } else if (sewb == 2) {
                    auto Vd = Vd_container.as<uint16_t>();
                    auto Vs2 = Vs2_container.as<uint16_t>();
                    auto Vs1 = Vs1_container.as<uint16_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        %(code)s;
                    }
                } else if (sewb == 4) {
                    auto Vd = Vd_container.as<uint32_t>();
                    auto Vs2 = Vs2_container.as<uint32_t>();
                    auto Vs1 = Vs1_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        %(code)s;
                    }
                } else if (sewb == 8) {
                    auto Vd = Vd_container.as<uint64_t>();
                    auto Vs2 = Vs2_container.as<uint64_t>();
                    auto Vs1 = Vs1_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        %(code)s;
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorIntegerCompareVVExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
             if (VD == 0 || VS1 == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorVdVs2Vs1Op using v0 "
                             "as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
             }
        }

        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, 0);
        auto Vd_mask = Vd_container.as<VecElem>();

        for (uint32_t destVecRegID = 0; destVecRegID < _numVecDestRegs; ++destVecRegID) {
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, destVecRegID);
            const TheISA::VecRegContainer& Vs1_container = xc->readVecRegOperand(this, destVecRegID + 1);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[destVecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[destVecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID/2];
                        vmask = (vmask >> (destVecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vs2 = Vs2_container.as<uint8_t>();
                    auto Vs1 = Vs1_container.as<uint8_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        uint32_t mask_reg_elem_idx =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 2) {
                    auto Vs2 = Vs2_container.as<uint16_t>();
                    auto Vs1 = Vs1_container.as<uint16_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        uint32_t mask_reg_elem_idx =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 4) {
                    auto Vs2 = Vs2_container.as<uint32_t>();
                    auto Vs1 = Vs1_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        uint32_t mask_reg_elem_idx =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 8) {
                    auto Vs2 = Vs2_container.as<uint64_t>();
                    auto Vs1 = Vs1_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        uint32_t mask_reg_elem_idx =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((destVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorOPIVXMaskExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
             if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorOPIVXMaskOp using v0 "
                             "as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
             }
        }

        uint64_t Rs1 =
          xc->readIntRegOperand(this, 0) & mask(sewb * 8);

        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, 0);
        auto Vd_mask = Vd_container.as<VecElem>();

        for (uint32_t srcVecRegID = 0; srcVecRegID < _numVecSrcRegs; ++srcVecRegID) {
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, srcVecRegID + 1);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[srcVecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[srcVecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[srcVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[srcVecRegID/2];
                        vmask = (vmask >> (srcVecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vs2 = Vs2_container.as<uint8_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 2) {
                    auto Vs2 = Vs2_container.as<uint16_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 4) {
                    auto Vs2 = Vs2_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 8) {
                    auto Vs2 = Vs2_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorOPIVXMaskCarryExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        assert(VM == 0);

        uint64_t Rs1 =
          xc->readIntRegOperand(this, 0) & mask(sewb * 8);

        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, 0);
        auto Vd_mask = Vd_container.as<VecElem>();

        for (uint32_t srcVecRegID = 0; srcVecRegID < _numVecSrcRegs; ++srcVecRegID) {
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, srcVecRegID + 1);

            uint32_t vmask = UINT32_MAX;
            const TheISA::VecRegContainer& Vmask_container =
                xc->readVecRegOperand(this, _numSrcRegs - 1);
            switch(sewb) {
                case 1:
                    vmask = Vmask_container.as<uint32_t>()[srcVecRegID];
                    break;
                case 2:
                    vmask = Vmask_container.as<uint16_t>()[srcVecRegID];
                    break;
                case 4:
                    vmask = Vmask_container.as<uint8_t>()[srcVecRegID];
                    break;
                case 8:
                    vmask = Vmask_container.as<uint8_t>()[srcVecRegID/2];
                    vmask = (vmask >> (srcVecRegID % 2));
                    break;
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vs2 = Vs2_container.as<uint8_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 2) {
                    auto Vs2 = Vs2_container.as<uint16_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 4) {
                    auto Vs2 = Vs2_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 8) {
                    auto Vs2 = Vs2_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorOPIVIMaskCarryExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        assert(VM == 0);

        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, 0);
        auto Vd_mask = Vd_container.as<VecElem>();

        for (uint32_t srcVecRegID = 0; srcVecRegID < _numVecSrcRegs; ++srcVecRegID) {
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, srcVecRegID);

            uint32_t vmask = UINT32_MAX;
            const TheISA::VecRegContainer& Vmask_container =
                xc->readVecRegOperand(this, _numSrcRegs - 1);
            switch(sewb) {
                case 1:
                    vmask = Vmask_container.as<uint32_t>()[srcVecRegID];
                    break;
                case 2:
                    vmask = Vmask_container.as<uint16_t>()[srcVecRegID];
                    break;
                case 4:
                    vmask = Vmask_container.as<uint8_t>()[srcVecRegID];
                    break;
                case 8:
                    vmask = Vmask_container.as<uint8_t>()[srcVecRegID/2];
                    vmask = (vmask >> (srcVecRegID % 2));
                    break;
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vs2 = Vs2_container.as<uint8_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 2) {
                    auto Vs2 = Vs2_container.as<uint16_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 4) {
                    auto Vs2 = Vs2_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 8) {
                    auto Vs2 = Vs2_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorOPIVVMaskCarryExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        assert(VM == 0);

        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, 0);
        auto Vd_mask = Vd_container.as<VecElem>();

        uint32_t numVecVs2Vs2Regs =
            ceil((float) vl / (VecRegSizeBytes / sewb));

        for (uint32_t srcVecRegID = 0; srcVecRegID < numVecVs2Vs2Regs; ++srcVecRegID) {
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, srcVecRegID);
            const TheISA::VecRegContainer& Vs1_container = xc->readVecRegOperand(this, srcVecRegID + 1);

            uint32_t vmask = UINT32_MAX;
            const TheISA::VecRegContainer& Vmask_container =
                xc->readVecRegOperand(this, _numSrcRegs - 1);
            switch(sewb) {
                case 1:
                    vmask = Vmask_container.as<uint32_t>()[srcVecRegID];
                    break;
                case 2:
                    vmask = Vmask_container.as<uint16_t>()[srcVecRegID];
                    break;
                case 4:
                    vmask = Vmask_container.as<uint8_t>()[srcVecRegID];
                    break;
                case 8:
                    vmask = Vmask_container.as<uint8_t>()[srcVecRegID/2];
                    vmask = (vmask >> (srcVecRegID % 2));
                    break;
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vs2 = Vs2_container.as<uint8_t>();
                    auto Vs1 = Vs1_container.as<uint8_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 2) {
                    auto Vs2 = Vs2_container.as<uint16_t>();
                    auto Vs1 = Vs1_container.as<uint16_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 4) {
                    auto Vs2 = Vs2_container.as<uint32_t>();
                    auto Vs1 = Vs1_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 8) {
                    auto Vs2 = Vs2_container.as<uint64_t>();
                    auto Vs1 = Vs1_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorIntegerCompareVIExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
             if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorIntegerCompareVIOp using v0 "
                             "as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
             }
        }

        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, 0);
        auto Vd_mask = Vd_container.as<VecElem>();

        for (uint32_t srcVecRegID = 0; srcVecRegID < _numVecSrcRegs; ++srcVecRegID) {
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, srcVecRegID);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[srcVecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[srcVecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[srcVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[srcVecRegID/2];
                        vmask = (vmask >> (srcVecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vs2 = Vs2_container.as<uint8_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 2) {
                    auto Vs2 = Vs2_container.as<uint16_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 4) {
                    auto Vs2 = Vs2_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 8) {
                    auto Vs2 = Vs2_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorFloatCompareVFExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        softfloat_roundingMode = xc->readMiscReg(MISCREG_FRM);;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
             if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorVdVs2Fs1Op using v0 "
                             "as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
             }
        }

        RegVal FFLAGS = xc->readMiscReg(MISCREG_FFLAGS);
        std::feclearexcept(FE_ALL_EXCEPT);

        uint64_t Fs1_bits = xc->readFloatRegOperandBits(this, 0);

        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, 0);
        auto Vd_mask = Vd_container.as<VecElem>();

        for (uint32_t srcVecRegID = 0; srcVecRegID < _numVecSrcRegs; ++srcVecRegID) {
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, srcVecRegID + 1);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[srcVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[srcVecRegID/2];
                        vmask = (vmask >> (srcVecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 4) {
                    auto Vs2_unboxed = Vs2_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 8) {
                    auto Vs2_unboxed = Vs2_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        FFLAGS |= softfloat_exceptionFlags;
        softfloat_exceptionFlags = 0;
        xc->setMiscReg(MISCREG_FFLAGS, FFLAGS);

        return fault;
    }
}};

def template VectorFloatCompareVVExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        softfloat_roundingMode = xc->readMiscReg(MISCREG_FRM);;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        if (VM == 0) {
             if (VD == 0 || VS2 == 0) {
                std::string error =
                    csprintf("Masked VectorVdVs2Fs1Op using v0 "
                             "as src/dst register\n");
                return std::make_shared<IllegalInstFault>(error, machInst);
             }
        }

        RegVal FFLAGS = xc->readMiscReg(MISCREG_FFLAGS);
        std::feclearexcept(FE_ALL_EXCEPT);

        TheISA::VecRegContainer& Vd_container = xc->getWritableVecRegOperand(this, 0);
        auto Vd_mask = Vd_container.as<VecElem>();

        for (uint32_t srcVecRegID = 0; srcVecRegID < _numVecSrcRegs; ++srcVecRegID) {
            const TheISA::VecRegContainer& Vs2_container = xc->readVecRegOperand(this, srcVecRegID);
            const TheISA::VecRegContainer& Vs1_container = xc->readVecRegOperand(this, srcVecRegID + 1);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[srcVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[srcVecRegID/2];
                        vmask = (vmask >> (srcVecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 4) {
                    auto Vs2_unboxed = Vs2_container.as<uint32_t>();
                    auto Vs1_unboxed = Vs1_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else if (sewb == 8) {
                    auto Vs2_unboxed = Vs2_container.as<uint64_t>();
                    auto Vs1_unboxed = Vs1_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }
                        uint32_t mask_reg_elem_idx =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) / (sizeof(VecElem) * 8);
                        uint32_t bit_position_in_mask =
                            ((srcVecRegID * num_target_elements_in_reg) + regElemID) % (sizeof(VecElem) * 8);

                        %(code)s;

                        Vd_mask[mask_reg_elem_idx] &= ~(1 << bit_position_in_mask);
                        Vd_mask[mask_reg_elem_idx] |= (result << bit_position_in_mask);
                    }
                } else {
                    std::string error = csprintf(
                        "Illegal vsewb value in VTYPE: 0x%x\n", vtype.vsew);
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        FFLAGS |= softfloat_exceptionFlags;
        softfloat_exceptionFlags = 0;
        xc->setMiscReg(MISCREG_FFLAGS, FFLAGS);

        return fault;
    }
}};

def template VectorUnitStrideMemLoadExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        uint32_t eewb = 0;
        switch (FUNCT3) {
            case 0:
                eewb = 1;
                break;
            case 5:
                eewb = 2;
                break;
            case 6:
                eewb = 4;
                break;
            case 7:
                eewb = 8;
                break;
            default:
                std::string error = csprintf(
                    "Illegal eew value: 0x%x\n", FUNCT3);
                return std::make_shared<IllegalInstFault>(error, machInst);
                break;
        }

        float vemul = ((float) eewb / sewb) * getVflmul(vtype.vlmul);

        if ((vemul < 0.125) || (vemul > 8)) {
            std::string error = csprintf(
                "Illegal vemul value: %f\n", vemul);
            return std::make_shared<IllegalInstFault>(error, machInst);
        }

        %(op_decl)s;

        Rs1 = xc->readIntRegOperand(this, 0);

        for (uint32_t destVecRegID = 0; destVecRegID < _numVecDestRegs; ++destVecRegID) {
            TheISA::VecRegContainer& Vd_container =
                xc->getWritableVecRegOperand(this, destVecRegID);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[destVecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[destVecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID/2];
                        vmask = (vmask >> (destVecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg = 0;
            if (LUMOP == 0 || LUMOP == 0x10) {
                // vle32.v        nf 28=0 27..26=0 vm 24..20=0 rs1 14..12=0x6  vd 6..0=0x07
                // vle32ff.v        nf 28=0 27..26=0 vm 24..20=0x10 rs1 14..12=0x6  vd 6..0=0x07
                num_target_elements_in_reg =
                    (VecRegSizeBytes/eewb) > vl ? vl : (VecRegSizeBytes/eewb);
            } else if (LUMOP == 0x8) {
                // vl1re32.v      31..29=0 28=0 27..26=0 25=1 24..20=0x08 rs1 14..12=0x6 vd  6..0=0x07
                num_target_elements_in_reg = xc->readMiscReg(MISCREG_VLENB) / eewb;
            }

            if (fault == NoFault) {
                if (eewb == 1) {
                    auto Vd = Vd_container.as<uint8_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        uint64_t offset =
                            (regElemID * sizeof(uint8_t)) +
                                (destVecRegID * num_target_elements_in_reg * sizeof(uint8_t));
                        %(code)s;
                    }
                } else if (eewb == 2) {
                    auto Vd = Vd_container.as<uint16_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        uint64_t offset =
                            (regElemID * sizeof(uint16_t)) +
                                (destVecRegID * num_target_elements_in_reg * sizeof(uint16_t));
                        %(code)s;
                    }
                } else if (eewb == 4) {
                    auto Vd = Vd_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        uint64_t offset =
                            (regElemID * sizeof(uint32_t)) +
                                (destVecRegID * num_target_elements_in_reg * sizeof(uint32_t));
                        %(code)s;
                    }
                } else if (eewb == 8) {
                    auto Vd = Vd_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        uint64_t offset =
                            (regElemID * sizeof(uint64_t)) +
                                (destVecRegID * num_target_elements_in_reg * sizeof(uint64_t));
                        %(code)s;
                    }
                } else {
                    std::string error = csprintf(
                        "Unexpected eewb value in instruction");
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        // TODO: Print all destination registers
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorStridedMemLoadExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        uint32_t eewb = 0;
        switch (FUNCT3) {
            case 0:
                eewb = 1;
                break;
            case 5:
                eewb = 2;
                break;
            case 6:
                eewb = 4;
                break;
            case 7:
                eewb = 8;
                break;
            default:
                std::string error = csprintf(
                    "Illegal eew value: 0x%x\n", FUNCT3);
                return std::make_shared<IllegalInstFault>(error, machInst);
                break;
        }

        float vemul = ((float) eewb / sewb) * getVflmul(vtype.vlmul);

        if ((vemul < 0.125) || (vemul > 8)) {
            std::string error = csprintf(
                "Illegal vemul value: %f\n", vemul);
            return std::make_shared<IllegalInstFault>(error, machInst);
        }

        %(op_decl)s;

        Rs1 = xc->readIntRegOperand(this, 0);
        Rs2 = xc->readIntRegOperand(this, 1);

        for (uint32_t destVecRegID = 0; destVecRegID < _numVecDestRegs; ++destVecRegID) {
            TheISA::VecRegContainer& Vd_container =
                xc->getWritableVecRegOperand(this, destVecRegID);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(eewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[destVecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[destVecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID/2];
                        vmask = (vmask >> (destVecRegID % 2));
                        break;
                }
            }

            size_t num_target_elements_in_reg =
                (VecRegSizeBytes/eewb) > vl ? vl : (VecRegSizeBytes/eewb);

            if (fault == NoFault) {
                if (eewb == 1) {
                    auto Vd = Vd_container.as<uint8_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        %(code)s;
                    }
                } else if (eewb == 2) {
                    auto Vd = Vd_container.as<uint16_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        %(code)s;
                    }
                } else if (eewb == 4) {
                    auto Vd = Vd_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        %(code)s;
                    }
                } else if (eewb == 8) {
                    auto Vd = Vd_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_target_elements_in_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        %(code)s;
                    }
                } else {
                    std::string error = csprintf(
                        "Unexpected eewb value in instruction");
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        // TODO: Print all destination registers
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_target_elements_in_reg;
            }
        }

        return fault;
    }
}};

def template VectorIndexedMemLoadExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        uint32_t eewb = 0;
        switch (FUNCT3) {
            case 0:
                eewb = 1;
                break;
            case 5:
                eewb = 2;
                break;
            case 6:
                eewb = 4;
                break;
            case 7:
                eewb = 8;
                break;
            default:
                std::string error = csprintf(
                    "Illegal eew value: 0x%x\n", FUNCT3);
                return std::make_shared<IllegalInstFault>(error, machInst);
                break;
        }

        float vemul = ((float) eewb / sewb) * getVflmul(vtype.vlmul);

        if ((vemul < 0.125) || (vemul > 8)) {
            std::string error = csprintf(
                "Illegal vemul value: %f\n", vemul);
            return std::make_shared<IllegalInstFault>(error, machInst);
        }

        %(op_decl)s;

        Rs1 = xc->readIntRegOperand(this, 0);

        size_t num_elements_in_src_reg = (VecRegSizeBytes/eewb);
        uint32_t srcVecRegID = 0;
        uint32_t srcVecRegElemID = 0;

        for (uint32_t destVecRegID = 0; destVecRegID < _numVecDestRegs; ++destVecRegID) {
            TheISA::VecRegContainer& Vd_container =
                xc->getWritableVecRegOperand(this, destVecRegID);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[destVecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[destVecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[destVecRegID/2];
                        vmask = (vmask >> (destVecRegID % 2));
                        break;
                }
            }

            size_t num_elements_in_dest_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vd = Vd_container.as<uint8_t>();
                    for (uint32_t regElemID = 0; regElemID < num_elements_in_dest_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        const TheISA::VecRegContainer& Vs2_container =
                            xc->readVecRegOperand(this, srcVecRegID + 1);

                        uint64_t offset = 0;
                        switch (eewb) {
                            case 1:
                                offset = Vs2_container.as<uint8_t>()[srcVecRegElemID];
                                break;
                            case 2:
                                offset = Vs2_container.as<uint16_t>()[srcVecRegElemID];
                                break;
                            case 4:
                                offset = Vs2_container.as<uint32_t>()[srcVecRegElemID];
                                break;
                            case 8:
                                offset = Vs2_container.as<uint64_t>()[srcVecRegElemID];
                                break;
                        }

                        uint8_t load_value;

                        %(code)s;

                        ++srcVecRegElemID;
                        if (srcVecRegElemID == num_elements_in_src_reg) {
                            srcVecRegElemID = 0;
                            ++srcVecRegID;
                        }
                    }
                } else if (sewb == 2) {
                    auto Vd = Vd_container.as<uint16_t>();
                    for (uint32_t regElemID = 0; regElemID < num_elements_in_dest_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        const TheISA::VecRegContainer& Vs2_container =
                            xc->readVecRegOperand(this, srcVecRegID + 1);

                        uint64_t offset = 0;
                        switch (eewb) {
                            case 1:
                                offset = Vs2_container.as<uint8_t>()[srcVecRegElemID];
                                break;
                            case 2:
                                offset = Vs2_container.as<uint16_t>()[srcVecRegElemID];
                                break;
                            case 4:
                                offset = Vs2_container.as<uint32_t>()[srcVecRegElemID];
                                break;
                            case 8:
                                offset = Vs2_container.as<uint64_t>()[srcVecRegElemID];
                                break;
                        }

                        uint16_t load_value;

                        %(code)s;

                        ++srcVecRegElemID;
                        if (srcVecRegElemID == num_elements_in_src_reg) {
                            srcVecRegElemID = 0;
                            ++srcVecRegID;
                        }
                    }
                } else if (sewb == 4) {
                    auto Vd = Vd_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_elements_in_dest_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        const TheISA::VecRegContainer& Vs2_container =
                            xc->readVecRegOperand(this, srcVecRegID + 1);

                        uint64_t offset = 0;
                        switch (eewb) {
                            case 1:
                                offset = Vs2_container.as<uint8_t>()[srcVecRegElemID];
                                break;
                            case 2:
                                offset = Vs2_container.as<uint16_t>()[srcVecRegElemID];
                                break;
                            case 4:
                                offset = Vs2_container.as<uint32_t>()[srcVecRegElemID];
                                break;
                            case 8:
                                offset = Vs2_container.as<uint64_t>()[srcVecRegElemID];
                                break;
                        }

                        uint32_t load_value;

                        %(code)s;

                        ++srcVecRegElemID;
                        if (srcVecRegElemID == num_elements_in_src_reg) {
                            srcVecRegElemID = 0;
                            ++srcVecRegID;
                        }
                    }
                } else if (sewb == 8) {
                    auto Vd = Vd_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_elements_in_dest_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        const TheISA::VecRegContainer& Vs2_container =
                            xc->readVecRegOperand(this, srcVecRegID + 1);

                        uint64_t offset = 0;
                        switch (eewb) {
                            case 1:
                                offset = Vs2_container.as<uint8_t>()[srcVecRegElemID];
                                break;
                            case 2:
                                offset = Vs2_container.as<uint16_t>()[srcVecRegElemID];
                                break;
                            case 4:
                                offset = Vs2_container.as<uint32_t>()[srcVecRegElemID];
                                break;
                            case 8:
                                offset = Vs2_container.as<uint64_t>()[srcVecRegElemID];
                                break;
                        }

                        uint64_t load_value;

                        %(code)s;

                        ++srcVecRegElemID;
                        if (srcVecRegElemID == num_elements_in_src_reg) {
                            srcVecRegElemID = 0;
                            ++srcVecRegID;
                        }
                    }
                } else {
                    std::string error = csprintf(
                        "Unexpected sewb value in instruction");
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                if (fault == NoFault) {
                    if (traceData) {
                        // TODO: Print all destination registers
                        traceData->setData(Vd_container);
                    }
                }

                vl = vl - num_elements_in_dest_reg;
            }
        }

        return fault;
    }
}};

def template VectorIndexedMemStoreExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        uint32_t eewb = 0;
        switch (FUNCT3) {
            case 0:
                eewb = 1;
                break;
            case 5:
                eewb = 2;
                break;
            case 6:
                eewb = 4;
                break;
            case 7:
                eewb = 8;
                break;
            default:
                std::string error = csprintf(
                    "Illegal eew value: 0x%x\n", FUNCT3);
                return std::make_shared<IllegalInstFault>(error, machInst);
                break;
        }

        float vemul = ((float) eewb / sewb) * getVflmul(vtype.vlmul);

        if ((vemul < 0.125) || (vemul > 8)) {
            std::string error = csprintf(
                "Illegal vemul value: %f\n", vemul);
            return std::make_shared<IllegalInstFault>(error, machInst);
        }

        %(op_decl)s;

        Rs1 = xc->readIntRegOperand(this, 0);

        size_t num_elements_in_vs2_reg = (VecRegSizeBytes/eewb);
        uint32_t vs2RegID = 0;
        uint32_t vs2RegElemID = 0;

        uint32_t numVs3VecRegs =
            ceil((float) vl / (VecRegSizeBytes/sewb));

        for (uint32_t vs3VecRegID = 0; vs3VecRegID < numVs3VecRegs; ++vs3VecRegID) {
            const TheISA::VecRegContainer& Vs3_container =
                xc->readVecRegOperand(this, vs3VecRegID + 1);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[vs3VecRegID];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[vs3VecRegID];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[vs3VecRegID];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[vs3VecRegID/2];
                        vmask = (vmask >> (vs3VecRegID % 2));
                        break;
                }
            }

            size_t num_elements_in_vs3_reg =
                (VecRegSizeBytes/sewb) > vl ? vl : (VecRegSizeBytes/sewb);

            if (fault == NoFault) {
                if (sewb == 1) {
                    auto Vd = Vs3_container.as<uint8_t>();
                    for (uint32_t regElemID = 0; regElemID < num_elements_in_vs3_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        const TheISA::VecRegContainer& Vs2_container =
                            xc->readVecRegOperand(this, numVs3VecRegs + vs2RegID + 1);

                        uint64_t offset = 0;
                        switch (eewb) {
                            case 1:
                                offset = Vs2_container.as<uint8_t>()[vs2RegElemID];
                                break;
                            case 2:
                                offset = Vs2_container.as<uint16_t>()[vs2RegElemID];
                                break;
                            case 4:
                                offset = Vs2_container.as<uint32_t>()[vs2RegElemID];
                                break;
                            case 8:
                                offset = Vs2_container.as<uint64_t>()[vs2RegElemID];
                                break;
                        }

                        %(code)s;

                        ++vs2RegElemID;
                        if (vs2RegElemID == num_elements_in_vs2_reg) {
                            vs2RegElemID = 0;
                            ++vs2RegID;
                        }
                    }
                } else if (sewb == 2) {
                    auto Vd = Vs3_container.as<uint16_t>();
                    for (uint32_t regElemID = 0; regElemID < num_elements_in_vs3_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        const TheISA::VecRegContainer& Vs2_container =
                            xc->readVecRegOperand(this, numVs3VecRegs + vs2RegID + 1);

                        uint64_t offset = 0;
                        switch (eewb) {
                            case 1:
                                offset = Vs2_container.as<uint8_t>()[vs2RegElemID];
                                break;
                            case 2:
                                offset = Vs2_container.as<uint16_t>()[vs2RegElemID];
                                break;
                            case 4:
                                offset = Vs2_container.as<uint32_t>()[vs2RegElemID];
                                break;
                            case 8:
                                offset = Vs2_container.as<uint64_t>()[vs2RegElemID];
                                break;
                        }

                        %(code)s;

                        ++vs2RegElemID;
                        if (vs2RegElemID == num_elements_in_vs2_reg) {
                            vs2RegElemID = 0;
                            ++vs2RegID;
                        }
                    }
                } else if (sewb == 4) {
                    auto Vd = Vs3_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_elements_in_vs3_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        const TheISA::VecRegContainer& Vs2_container =
                            xc->readVecRegOperand(this, numVs3VecRegs + vs2RegID + 1);

                        uint64_t offset = 0;
                        switch (eewb) {
                            case 1:
                                offset = Vs2_container.as<uint8_t>()[vs2RegElemID];
                                break;
                            case 2:
                                offset = Vs2_container.as<uint16_t>()[vs2RegElemID];
                                break;
                            case 4:
                                offset = Vs2_container.as<uint32_t>()[vs2RegElemID];
                                break;
                            case 8:
                                offset = Vs2_container.as<uint64_t>()[vs2RegElemID];
                                break;
                        }

                        %(code)s;

                        ++vs2RegElemID;
                        if (vs2RegElemID == num_elements_in_vs2_reg) {
                            vs2RegElemID = 0;
                            ++vs2RegID;
                        }
                    }
                } else if (sewb == 8) {
                    auto Vd = Vs3_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_elements_in_vs3_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        const TheISA::VecRegContainer& Vs2_container =
                            xc->readVecRegOperand(this, numVs3VecRegs + vs2RegID + 1);

                        uint64_t offset = 0;
                        switch (eewb) {
                            case 1:
                                offset = Vs2_container.as<uint8_t>()[vs2RegElemID];
                                break;
                            case 2:
                                offset = Vs2_container.as<uint16_t>()[vs2RegElemID];
                                break;
                            case 4:
                                offset = Vs2_container.as<uint32_t>()[vs2RegElemID];
                                break;
                            case 8:
                                offset = Vs2_container.as<uint64_t>()[vs2RegElemID];
                                break;
                        }

                        %(code)s;

                        ++vs2RegElemID;
                        if (vs2RegElemID == num_elements_in_vs2_reg) {
                            vs2RegElemID = 0;
                            ++vs2RegID;
                        }
                    }
                } else {
                    std::string error = csprintf(
                        "Unexpected sewb value in instruction");
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                vl = vl - num_elements_in_vs3_reg;
            }
        }

        return fault;
    }
}};

def template VectorUnitStrideMemStoreExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        uint32_t eewb = 0;
        switch (FUNCT3) {
            case 0:
                eewb = 1;
                break;
            case 5:
                eewb = 2;
                break;
            case 6:
                eewb = 4;
                break;
            case 7:
                eewb = 8;
                break;
            default:
                std::string error = csprintf(
                    "Illegal eew value: 0x%x\n", FUNCT3);
                return std::make_shared<IllegalInstFault>(error, machInst);
                break;
        }

        float vemul = ((float) eewb / sewb) * getVflmul(vtype.vlmul);

        if ((vemul < 0.125) || (vemul > 8)) {
            std::string error = csprintf(
                "Illegal vemul value: %f\n", vemul);
            return std::make_shared<IllegalInstFault>(error, machInst);
        }

        %(op_decl)s;

        Rs1 = xc->readIntRegOperand(this, 0);

        for (uint32_t srcVecRegIdx = 0; srcVecRegIdx < _numVecSrcRegs; ++srcVecRegIdx) {
            const TheISA::VecRegContainer& Vs3_container = xc->readVecRegOperand(this, srcVecRegIdx + 1);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(sewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[srcVecRegIdx];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[srcVecRegIdx];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[srcVecRegIdx];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[srcVecRegIdx/2];
                        vmask = (vmask >> (srcVecRegIdx % 2));
                        break;
                }
            }

            size_t num_elements_in_vector_reg = 0;
            if (LUMOP == 0 || LUMOP == 0x10) {
                // vle32.v        nf 28=0 27..26=0 vm 24..20=0 rs1 14..12=0x6  vd 6..0=0x07
                // vle32ff.v        nf 28=0 27..26=0 vm 24..20=0x10 rs1 14..12=0x6  vd 6..0=0x07
                num_elements_in_vector_reg =
                    (VecRegSizeBytes/eewb) > vl ? vl : (VecRegSizeBytes/eewb);
            } else if (LUMOP == 0x8) {
                // vl1re32.v      31..29=0 28=0 27..26=0 25=1 24..20=0x08 rs1 14..12=0x6 vd  6..0=0x07
                num_elements_in_vector_reg = xc->readMiscReg(MISCREG_VLENB) / eewb;
            }

            if (fault == NoFault) {
                if (eewb == 1) {
                    auto Vs3 = Vs3_container.as<uint8_t>();
                    for (uint32_t regElemID = 0; regElemID < num_elements_in_vector_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        uint64_t offset =
                            (regElemID * sizeof(uint8_t)) +
                                (srcVecRegIdx * num_elements_in_vector_reg * sizeof(uint8_t));

                        %(code)s;
                    }
                } else if (eewb == 2) {
                    auto Vs3 = Vs3_container.as<uint16_t>();
                    for (uint32_t regElemID = 0; regElemID < num_elements_in_vector_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        uint64_t offset =
                            (regElemID * sizeof(uint16_t)) +
                                (srcVecRegIdx * num_elements_in_vector_reg * sizeof(uint16_t));

                        %(code)s;
                    }
                } else if (eewb == 4) {
                    auto Vs3 = Vs3_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_elements_in_vector_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        uint64_t offset =
                            (regElemID * sizeof(uint32_t)) +
                                (srcVecRegIdx * num_elements_in_vector_reg * sizeof(uint32_t));

                        %(code)s;
                    }
                } else if (eewb == 8) {
                    auto Vs3 = Vs3_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_elements_in_vector_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        uint64_t offset =
                            (regElemID * sizeof(uint64_t)) +
                                (srcVecRegIdx * num_elements_in_vector_reg * sizeof(uint64_t));

                        %(code)s;
                    }
                } else {
                    std::string error = csprintf(
                        "Unexpected eewb value in instruction");
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                vl = vl - num_elements_in_vector_reg;
            }
        }

        return fault;
    }
}};

def template VectorStridedMemStoreExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t vl = xc->readMiscReg(MISCREG_VL);
        VTYPE vtype = xc->readMiscReg(MISCREG_VTYPE);
        size_t sewb = getSew(vtype.vsew) / 8;

        uint32_t eewb = 0;
        switch (FUNCT3) {
            case 0:
                eewb = 1;
                break;
            case 5:
                eewb = 2;
                break;
            case 6:
                eewb = 4;
                break;
            case 7:
                eewb = 8;
                break;
            default:
                std::string error = csprintf(
                    "Illegal eew value: 0x%x\n", FUNCT3);
                return std::make_shared<IllegalInstFault>(error, machInst);
                break;
        }

        float vemul = ((float) eewb / sewb) * getVflmul(vtype.vlmul);

        if ((vemul < 0.125) || (vemul > 8)) {
            std::string error = csprintf(
                "Illegal vemul value: %f\n", vemul);
            return std::make_shared<IllegalInstFault>(error, machInst);
        }

        %(op_decl)s;

        Rs1 = xc->readIntRegOperand(this, 0);
        Rs2 = xc->readIntRegOperand(this, 1);

        for (uint32_t srcVecRegIdx = 0; srcVecRegIdx < _numVecSrcRegs; ++srcVecRegIdx) {
            const TheISA::VecRegContainer& Vs3_container = xc->readVecRegOperand(this, srcVecRegIdx + 2);

            uint32_t vmask = UINT32_MAX;
            if (VM == 0) {
                const TheISA::VecRegContainer& Vmask_container =
                    xc->readVecRegOperand(this, _numSrcRegs - 1);
                switch(eewb) {
                    case 1:
                        vmask = Vmask_container.as<uint32_t>()[srcVecRegIdx];
                        break;
                    case 2:
                        vmask = Vmask_container.as<uint16_t>()[srcVecRegIdx];
                        break;
                    case 4:
                        vmask = Vmask_container.as<uint8_t>()[srcVecRegIdx];
                        break;
                    case 8:
                        vmask = Vmask_container.as<uint8_t>()[srcVecRegIdx/2];
                        vmask = (vmask >> (srcVecRegIdx % 2));
                        break;
                }
            }

            size_t num_elements_in_vector_reg =
                (VecRegSizeBytes/eewb) > vl ? vl : (VecRegSizeBytes/eewb);

            if (fault == NoFault) {
                if (eewb == 1) {
                    auto Vs3 = Vs3_container.as<uint8_t>();
                    for (uint32_t regElemID = 0; regElemID < num_elements_in_vector_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        %(code)s;
                    }
                } else if (eewb == 2) {
                    auto Vs3 = Vs3_container.as<uint16_t>();
                    for (uint32_t regElemID = 0; regElemID < num_elements_in_vector_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        %(code)s;
                    }
                } else if (eewb == 4) {
                    auto Vs3 = Vs3_container.as<uint32_t>();
                    for (uint32_t regElemID = 0; regElemID < num_elements_in_vector_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        %(code)s;
                    }
                } else if (eewb == 8) {
                    auto Vs3 = Vs3_container.as<uint64_t>();
                    for (uint32_t regElemID = 0; regElemID < num_elements_in_vector_reg; ++regElemID) {
                        if (bits(vmask, regElemID, regElemID) == 0) {
                            continue;
                        }

                        %(code)s;
                    }
                } else {
                    std::string error = csprintf(
                        "Unexpected eewb value in instruction");
                    return std::make_shared<IllegalInstFault>(error, machInst);
                }

                vl = vl - num_elements_in_vector_reg;
            }
        }

        return fault;
    }
}};

def template VectorConfigExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        %(op_decl)s;
        %(op_rd)s;

        if (fault == NoFault) {

            %(code)s;

            if (fault == NoFault) {
                %(op_wb)s;
            }
        }
        return fault;
    }
}};

def template VectorVdVs2Rs1Declare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example: vadd.vx        31..26=0x00 vm vs2 rs1 14..12=0x4 vd 6..0=0x57
        //          vfadd.vf        31..26=0x00 vm vs2 rs1 14..12=0x5 vd 6..0=0x57
        // Sources: Rs1 + up to 8 vector regs starting at Vs2 and
        //          1 mask register.
        RegId srcRegIdxArr[1 + 8 + 1];
        // Destinations: up to 8 vector regs starting at Vd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorIntegerExtensionDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vzext.vf8      31..26=0x12 vm vs2 19..15=2 14..12=0x2 vd 6..0=0x57
        // Sources: up to 8 vector regs starting at Vs2 and
        //          1 mask register.
        RegId srcRegIdxArr[8 + 1];
        // Destinations: up to 8 vector regs starting at Vd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorMaskRegisterVdVs2Vs1Declare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vmxnor.mm      31..26=0x1f vm vs2 vs1 14..12=0x2 vd 6..0=0x57
        // Sources: Vs1 and Vs2
        RegId srcRegIdxArr[1 + 1];
        // Destinations: Vd
        RegId destRegIdxArr[1];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorMaskRegisterVdVs2Declare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vmsbf.m        31..26=0x14 vm vs2 19..15=0x01 14..12=0x2 vd 6..0=0x57
        // Sources: Vs2 and a mask register.
        RegId srcRegIdxArr[1 + 1];
        // Destinations: Vd
        RegId destRegIdxArr[1];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorWholeRegisterMoveDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vmv1r.v        31..26=0x27 25=1 vs2 19..15=0 14..12=0x3 vd 6..0=0x57
        // Sources: Up to 8 vector regs starting at Vs1
        RegId srcRegIdxArr[8];
        // Destinations: up to 8 vector regs starting at Vd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorVFUNARY0Declare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vfcvt.rtz.xu.f.v 31..26=0x12 vm vs2 19..15=0x06 14..12=0x1 vd 6..0=0x57
        // Sources: up to 8 vector regs starting at Vs2 and
        //          1 mask register.
        RegId srcRegIdxArr[8 + 1];
        // Destinations: up to 8 vector regs starting at Vd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorOPIVIDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vadd.vi        31..26=0x00 vm vs2 simm5 14..12=0x3 vd 6..0=0x57
        // Sources: up to 8 vector regs starting at Vs2 and
        //          1 mask register.
        RegId srcRegIdxArr[8 + 8 + 1];
        // Destinations: up to 8 vector regs starting at Vd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorVdVs2Vs1Declare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vadd.vv         31..26=0x00 vm vs2 vs1 14..12=0x0 vd 6..0=0x57
        // Sources: up to 8 vector regs starting at Vs2 and
        //          up to 8 vector regs starting at Vs1 and
        //          1 mask register.
        RegId srcRegIdxArr[8 + 8 + 1];
        // Destinations: up to 8 vector regs starting at Vd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorSingleWidthIntegerReductionDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vredsum.vs     31..26=0x00 vm vs2 vs1 14..12=0x2 vd 6..0=0x57
        // Sources: up to 8 vector regs starting at Vs2 and
        //          1 vector reg starting at Vs1 and
        //          1 mask register.
        RegId srcRegIdxArr[8 + 1 + 1];
        // Destinations: up to 1 vector regs starting at Vd
        RegId destRegIdxArr[1];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorNarrowingVIDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vnclipu.wi     31..26=0x2e vm vs2 simm5 14..12=0x3 vd 6..0=0x57
        // Sources: up to 8 vector regs starting at Vs2 and
        //          1 mask register.
        RegId srcRegIdxArr[8 + 1];
        // Destinations: up to 8 vector regs starting at Vd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorNarrowingWXDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vnclipu.wi     31..26=0x2e vm vs2 simm5 14..12=0x3 vd 6..0=0x57
        // Sources: up to 8 vector regs starting at Vs2 and
        //          Rs1 and
        //          1 mask register.
        RegId srcRegIdxArr[8 + 1 + 1];
        // Destinations: up to 8 vector regs starting at Vd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorWideningVXDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vwsub.vx       31..26=0x33 vm vs2 rs1 14..12=0x6 vd 6..0=0x57
        // Sources: up to 8 vector regs starting at Vs2 and
        //          Rs1 and
        //          1 mask register.
        RegId srcRegIdxArr[8 + 1 + 1];
        // Destinations: up to 8 vector regs starting at Vd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorWideningWVDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        //
        // vwadd.wv       31..26=0x35 vm vs2 vs1 14..12=0x2 vd 6..0=0x57
        // Sources: up to 8 vector regs starting at Vs2 and
        //          up to 8 vector regs starting at Vs1 and
        //          1 mask register.
        RegId srcRegIdxArr[8 + 8 + 1];
        // Destinations: up to 8 vector regs starting at Vd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorWideningVVDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vwsubu.vv      31..26=0x32 vm vs2 vs1 14..12=0x2 vd 6..0=0x57
        // Sources: up to 8 vector regs starting at Vs2 and
        //          up to 8 vector regs starting at Vs1 and
        //          1 mask register.
        RegId srcRegIdxArr[8 + 8 + 1];
        // Destinations: up to 8 vector regs starting at Vd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorNarrowingVVDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vnclipu.wv     31..26=0x2e vm vs2 vs1 14..12=0x0 vd 6..0=0x57
        // Sources: up to 8 vector regs starting at Vs2 and
        //          up to 8 vector regs starting at Vs1 and
        //          1 mask register.
        RegId srcRegIdxArr[8 + 8 + 1];
        // Destinations: up to 8 vector regs starting at Vd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorUnitStrideMemLoadDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vle32.v        nf 28=0 27..26=0 vm 24..20=0 rs1 14..12=0x6  vd 6..0=0x07
        // Sources: Rs1 + 1 mask register.
        RegId srcRegIdxArr[1 + 1];
        // Destinations: up to 8 vector regs starting at Vd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorStridedMemLoadDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vlse64.v        nf 28=0 27..26=2 vm rs2 rs1 14..12=0x7  vd 6..0=0x07
        // Sources: Rs1 + Rs2 + 1 mask register.
        RegId srcRegIdxArr[1 + 1 + 1];
        // Destinations: up to 8 vector regs starting at Vd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorIndexedMemLoadDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    // vluxei32.v     nf 28=0 27..26=1 vm vs2 rs1 14..12=0x6  vd 6..0=0x07
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        //
        // Sources: Rs1 + up to 8 vector registers starting at Vs2
        //          + 1 mask register.
        RegId srcRegIdxArr[1 + 8 + 1];
        // Destinations: up to 8 vector regs starting at Vd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorIndexedMemStoreDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    // vsuxei32.v     nf 28=0 27..26=1 vm vs2 rs1 14..12=0x6 vs3 6..0=0x27
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        //
        // Sources: Rs1 + up to 8 vector registers starting at Vs2
        //          + up to 8 vector registers starting at Vd + 1 mask register.
        RegId srcRegIdxArr[1 + 8 + 8 + 1];
        // Need a dummy destRegIdxArr even though we have no destination regs
        RegId destRegIdxArr[0];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorUnitStrideMemStoreDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vse32.v        nf 28=0 27..26=0 vm 24..20=0 rs1 14..12=0x6 vs3 6..0=0x27
        // Sources: Rs1 + up to 8 vector registers starting at Vs3 and
        //          1 mask register.
        RegId srcRegIdxArr[1 + 8 + 1];

        // Need a dummy destRegIdxArr even though we have no destination regs
        RegId destRegIdxArr[0];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorStridedMemStoreDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vsse64.v        nf 28=0 27..26=2 vm rs2 rs1 14..12=0x7 vs3 6..0=0x27
        // Sources: Rs1 + Rs2 + 8 vector registers starting at Vs3 and
        //  1 mask register.
        RegId srcRegIdxArr[1 + 1 + 8 + 1];

        // Need a dummy destRegIdxArr even though we have no destination regs
        RegId destRegIdxArr[0];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};


def template VectorDecode {{
    return new %(class_name)s(machInst, getVtype(), getVl());
}};

def template VectorVMUNARY0Declare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vid.v          31..26=0x14 vm 24..20=0 19..15=0x11 14..12=0x2 vd 6..0=0x57
        RegId srcRegIdxArr[1];

        // Up to 8 vector registers starting at Vd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorVMUNARYVs20Declare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // viota.m        31..26=0x14 vm vs2 19..15=0x10 14..12=0x2 vd 6..0=0x57
        RegId srcRegIdxArr[2];

        // Up to 8 vector registers starting at Vd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorVWXUNARY0Declare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vmv.x.s        31..26=0x10 25=1 vs2 19..15=0 14..12=0x2 rd 6..0=0x57
        RegId srcRegIdxArr[8];

        // Rd
        RegId destRegIdxArr[1];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorVWXUNARY0MaskDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vcpop.m        31..26=0x10 vm vs2 19..15=0x10 14..12=0x2 rd 6..0=0x57
        // Sources: 1 vector reg Vs2
        //          1 mask register.
        RegId srcRegIdxArr[2];

        // Rd
        RegId destRegIdxArr[1];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorVRFUNARY0Declare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vfmv.s.f        31..26=0x10 25=1 24..20=0 rs1      14..12=0x5 vd 6..0=0x57
        RegId srcRegIdxArr[1];

        // Rd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorVWFUNARY0Declare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vfmv.f.s       31..26=0x10 25=1 vs2      19..15=0 14..12=0x1 rd 6..0=0x57
        RegId srcRegIdxArr[1];

        // Rd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorVRXUNARY0Declare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        // Example:
        // vmv.s.x        31..26=0x10 25=1 24..20=0 rs1 14..12=0x6 vd 6..0=0x57
        RegId srcRegIdxArr[1];

        // Rd
        RegId destRegIdxArr[8];

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def template VectorDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s
    {
      private:
        %(reg_idx_arr_decl)s;

      public:
        /// Constructor.
        %(class_name)s(MachInst machInst, RiscvISA::VTYPE vtype, uint32_t vl);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};

def format VectorVMUNARY0Op(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVMUNARY0Op', code, opt_flags)
    header_output = VectorVMUNARY0Declare.subst(iop)
    decoder_output = VectorVMUNARY0Constructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorVMUNARY0Execute.subst(iop)
}};

def format VectorVMUNARYVs20Op(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVMUNARYVs20Op', code, opt_flags)
    header_output = VectorVMUNARYVs20Declare.subst(iop)
    decoder_output = VectorVMUNARYVs20Constructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorVMUNARYVs20Execute.subst(iop)
}};

def format VectorVWXUNARY0Op(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVWXUNARY0Op', code, opt_flags)
    header_output = VectorVWXUNARY0Declare.subst(iop)
    decoder_output = VectorVWXUNARY0Constructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorVWXUNARY0Execute.subst(iop)
}};

def format VectorVWXUNARY0MaskOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVWXUNARY0Op', code, opt_flags)
    header_output = VectorVWXUNARY0MaskDeclare.subst(iop)
    decoder_output = VectorVWXUNARY0MaskConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorVWXUNARY0MaskExecute.subst(iop)
}};

def format VectorVRXUNARY0Op(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVRXUNARY0Op', code, opt_flags)
    header_output = VectorVRXUNARY0Declare.subst(iop)
    decoder_output = VectorVRXUNARY0Constructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorVRXUNARY0Execute.subst(iop)
}};

def format VectorVRFUNARY0Op(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVRFUNARY0Op', code, opt_flags)
    header_output = VectorVRFUNARY0Declare.subst(iop)
    decoder_output = VectorVRFUNARY0Constructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorVRFUNARY0Execute.subst(iop)
}};

def format VectorVWFUNARY0Op(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVWFUNARY0Op', code, opt_flags)
    header_output = VectorVWFUNARY0Declare.subst(iop)
    decoder_output = VectorVWFUNARY0Constructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorVWFUNARY0Execute.subst(iop)
}};

def format VectorVFUNARY0Op(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVFUNARY0Op', code, opt_flags)
    header_output = VectorVFUNARY0Declare.subst(iop)
    decoder_output = VectorVFUNARY0Constructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorVFUNARY0Execute.subst(iop)
}};


def format VectorOPIVIOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorOPIVIOp', code, opt_flags)
    header_output = VectorOPIVIDeclare.subst(iop)
    decoder_output = VectorOPIVIConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorOPIVIExecute.subst(iop)
}};

def format VectorVRGatherVIOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorOPIVIOp', code, opt_flags)
    header_output = VectorOPIVIDeclare.subst(iop)
    decoder_output = VectorOPIVIConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorVRGatherVIExecute.subst(iop)
}};

def format VectorOPIVICarryOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorOPIVIOp', code, opt_flags)
    header_output = VectorOPIVIDeclare.subst(iop)
    decoder_output = VectorOPIVIConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorOPIVICarryExecute.subst(iop)
}};

def format VectorVdVs2Rs1Op(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Rs1Op', code, opt_flags)
    header_output = VectorVdVs2Rs1Declare.subst(iop)
    decoder_output = VectorVdVs2Rs1Constructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorVdVs2Rs1Execute.subst(iop)
}};

def format VectorVRGatherVXOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Rs1Op', code, opt_flags)
    header_output = VectorVdVs2Rs1Declare.subst(iop)
    decoder_output = VectorVdVs2Rs1Constructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorVRGatherVXExecute.subst(iop)
}};

def format VectorOPIVXCarryOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Rs1Op', code, opt_flags)
    header_output = VectorVdVs2Rs1Declare.subst(iop)
    decoder_output = VectorVdVs2Rs1Constructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorOPIVXCarryExecute.subst(iop)
}};

def format VectorVdMaskVs2Rs1Op(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Rs1Op', code, opt_flags)
    header_output = VectorVdVs2Rs1Declare.subst(iop)
    decoder_output = VectorVdMaskVs2Rs1Constructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorVdMaskVs2Rs1Execute.subst(iop)
}};

def format VectorVdMaskOPIVIOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorOPIVIOp', code, opt_flags)
    header_output = VectorOPIVIDeclare.subst(iop)
    decoder_output = VectorVdMaskOPIVIConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorVdMaskOPIVIExecute.subst(iop)
}};

def format VectorVdMaskVs2Vs1Op(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Vs1Op', code, opt_flags)
    header_output = VectorVdVs2Vs1Declare.subst(iop)
    decoder_output = VectorVdMaskVs2Vs1Constructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorVdMaskVs2Vs1Execute.subst(iop)
}};

def format VectorWideningVXOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorWideningVXOp', code, opt_flags)
    header_output = VectorWideningVXDeclare.subst(iop)
    decoder_output = VectorWideningVXConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorWideningVXExecute.subst(iop)
}};

def format VectorWideningWVOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorWideningWVOp', code, opt_flags)
    header_output = VectorWideningWVDeclare.subst(iop)
    decoder_output = VectorWideningWVConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorWideningWVExecute.subst(iop)
}};

def format VectorWideningVVOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorWideningVVOp', code, opt_flags)
    header_output = VectorWideningVVDeclare.subst(iop)
    decoder_output = VectorWideningVVConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorWideningVVExecute.subst(iop)
}};

def format VectorSingleWidthIntegerReductionOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Vs1Op', code, opt_flags)
    header_output = VectorSingleWidthIntegerReductionDeclare.subst(iop)
    decoder_output = VectorSingleWidthIntegerReductionConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorSingleWidthIntegerReductionExecute.subst(iop)
}};

def format VectorWideningFPReductionOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Vs1Op', code, opt_flags)
    header_output = VectorVdVs2Vs1Declare.subst(iop)
    decoder_output = VectorWideningFPReductionConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorWideningFPReductionExecute.subst(iop)
}};

def format VectorWideningVdVs2Op(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorWideningVdVs2Op', code, opt_flags)
    header_output = VectorVdVs2Vs1Declare.subst(iop)
    decoder_output = VectorWideningVdVs2Constructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorWideningVdVs2Execute.subst(iop)
}};

def format VectorWideningVdFs1Vs2Op(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Fs1Op', code, opt_flags)
    header_output = VectorVdVs2Rs1Declare.subst(iop)
    decoder_output = VectorWideningVdFs1Vs2Constructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorWideningVdFs1Vs2Execute.subst(iop)
}};

def format VectorNarrowingVVOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorNarrowingVVOp', code, opt_flags)
    header_output = VectorNarrowingVVDeclare.subst(iop)
    decoder_output = VectorNarrowingVVConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorNarrowingVVExecute.subst(iop)
}};

def format VectorNarrowingVIOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorNarrowingVIOp', code, opt_flags)
    header_output = VectorNarrowingVIDeclare.subst(iop)
    decoder_output = VectorNarrowingVIConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorNarrowingVIExecute.subst(iop)
}};

def format VectorNarrowingWXOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorNarrowingWXOp', code, opt_flags)
    header_output = VectorNarrowingWXDeclare.subst(iop)
    decoder_output = VectorNarrowingWXConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorNarrowingWXExecute.subst(iop)
}};

def format VectorVdVs2Vs1Op(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Vs1Op', code, opt_flags)
    header_output = VectorVdVs2Vs1Declare.subst(iop)
    decoder_output = VectorVdVs2Vs1OpConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorVdVs2Vs1OpExecute.subst(iop)
}};

def format VectorOPFVVOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Vs1Op', code, opt_flags)
    header_output = VectorVdVs2Vs1Declare.subst(iop)
    decoder_output = VectorVdVs2Vs1OpConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorOPFVVOpExecute.subst(iop)
}};

def format VectorVRGatherVVOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Vs1Op', code, opt_flags)
    header_output = VectorVdVs2Vs1Declare.subst(iop)
    decoder_output = VectorVdVs2Vs1OpConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorVRGatherVVOpExecute.subst(iop)
}};

def format VectorOPIVVCarryOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Vs1Op', code, opt_flags)
    header_output = VectorVdVs2Vs1Declare.subst(iop)
    decoder_output = VectorVdVs2Vs1OpConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorOPIVVCarryExecute.subst(iop)
}};

def format VectorIntegerCompareVVOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Vs1Op', code, opt_flags)
    header_output = VectorVdVs2Vs1Declare.subst(iop)
    decoder_output = VectorIntegerCompareVVConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorIntegerCompareVVExecute.subst(iop)
}};

def format VectorOPIVXMaskOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Rs1Op', code, opt_flags)
    header_output = VectorVdVs2Rs1Declare.subst(iop)
    decoder_output = VectorOPIVXMaskConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorOPIVXMaskExecute.subst(iop)
}};

def format VectorOPIVXMaskCarryOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Rs1Op', code, opt_flags)
    header_output = VectorVdVs2Rs1Declare.subst(iop)
    decoder_output = VectorOPIVXMaskConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorOPIVXMaskCarryExecute.subst(iop)
}};

def format VectorOPIVIMaskCarryOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorOPIVIOp', code, opt_flags)
    header_output = VectorOPIVIDeclare.subst(iop)
    decoder_output = VectorOPIVIMaskConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorOPIVIMaskCarryExecute.subst(iop)
}};

def format VectorOPIVVMaskCarryOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Vs1Op', code, opt_flags)
    header_output = VectorVdVs2Vs1Declare.subst(iop)
    decoder_output = VectorVdMaskVs2Vs1Constructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorOPIVVMaskCarryExecute.subst(iop)
}};

def format VectorIntegerCompareVIOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorOPIVIOp', code, opt_flags)
    header_output = VectorOPIVIDeclare.subst(iop)
    decoder_output = VectorIntegerCompareVIConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorIntegerCompareVIExecute.subst(iop)
}};

def format VectorFloatCompareVFOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Fs1Op', code, opt_flags)
    header_output = VectorVdVs2Rs1Declare.subst(iop)
    decoder_output = VectorFloatCompareVFConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorFloatCompareVFExecute.subst(iop)
}};

def format VectorFloatCompareVVOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Vs1Op', code, opt_flags)
    header_output = VectorVdVs2Vs1Declare.subst(iop)
    decoder_output = VectorFloatCompareVVConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorFloatCompareVVExecute.subst(iop)
}};

def format VectorUnitStrideMemLoadOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorUnitStrideMemLoadOp', code, opt_flags)
    header_output = VectorUnitStrideMemLoadDeclare.subst(iop)
    decoder_output = VectorUnitStrideMemLoadConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorUnitStrideMemLoadExecute.subst(iop)
}};

def format VectorStridedMemLoadOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorStridedMemLoadOp', code, opt_flags)
    header_output = VectorStridedMemLoadDeclare.subst(iop)
    decoder_output = VectorStridedMemLoadConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorStridedMemLoadExecute.subst(iop)
}};

def format VectorIndexedMemLoadOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorIndexedMemLoadOp', code, opt_flags)
    header_output = VectorIndexedMemLoadDeclare.subst(iop)
    decoder_output = VectorIndexedMemLoadConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorIndexedMemLoadExecute.subst(iop)
}};

def format VectorIndexedMemStoreOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorIndexedMemStoreOp', code, opt_flags)
    header_output = VectorIndexedMemStoreDeclare.subst(iop)
    decoder_output = VectorIndexedMemStoreConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorIndexedMemStoreExecute.subst(iop)
}};

def format VectorUnitStrideMemStoreOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorUnitStrideMemStoreOp', code, opt_flags)
    header_output = VectorUnitStrideMemStoreDeclare.subst(iop)
    decoder_output = VectorUnitStrideMemStoreConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorUnitStrideMemStoreExecute.subst(iop)
}};

def format VectorStridedMemStoreOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorStridedMemStoreOp', code, opt_flags)
    header_output = VectorStridedMemStoreDeclare.subst(iop)
    decoder_output = VectorStridedMemStoreConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorStridedMemStoreExecute.subst(iop)
}};

def format VectorCfgOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorCfgOp', code, opt_flags)
    header_output = VectorDeclare.subst(iop)
    decoder_output = VectorCfgConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorConfigExecute.subst(iop)
}};

def format VectorVdVs2Fs1Op(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorVdVs2Fs1Op', code, opt_flags)
    header_output = VectorVdVs2Rs1Declare.subst(iop)
    decoder_output = VectorVdVs2Fs1Constructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorVdVs2Fs1Execute.subst(iop)
}};

def format VectorIntegerExtensionOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorIntegerExtensionOp', code, opt_flags)
    header_output = VectorIntegerExtensionDeclare.subst(iop)
    decoder_output = VectorIntegerExtensionConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorIntegerExtensionExecute.subst(iop)
}};

def format VectorMaskRegisterVdVs2Vs1Op(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorMaskRegisterVdVs2Vs1Op', code, opt_flags)
    header_output = VectorMaskRegisterVdVs2Vs1Declare.subst(iop)
    decoder_output = VectorMaskRegisterVdVs2Vs1Constructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorMaskRegisterVdVs2Vs1Execute.subst(iop)
}};

def format VectorMaskRegisterVdVs2Op(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorMaskRegisterVdVs2Op', code, opt_flags)
    header_output = VectorMaskRegisterVdVs2Declare.subst(iop)
    decoder_output = VectorMaskRegisterVdVs2Constructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorMaskRegisterVdVs2Execute.subst(iop)
}};

def format VectorWholeRegisterMoveOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'VectorWholeRegisterMoveOp', code, opt_flags)
    header_output = VectorWholeRegisterMoveDeclare.subst(iop)
    decoder_output = VectorWholeRegisterMoveConstructor.subst(iop)
    decode_block = VectorDecode.subst(iop)
    exec_output = VectorWholeRegisterMoveExecute.subst(iop)
}};

